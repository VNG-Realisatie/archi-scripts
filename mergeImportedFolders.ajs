/**
 * mergeImportedFolders.ajs
 * 
 * merge duplicated folder after an import of an archimate file into selected model
 * 	this script repairs the duplication of folders after an import of a model that is created from an exchange format file
 * 	this is a workaround for limitation of exporting and importing the IDs of folders in exchange format
 * 	see https://github.com/archimatetool/archi/issues/690
 * 
 * Flow for synchronizing architecture model:
 * 	- Archi: export model to Open Exchange File
 * 	- Wiki: import model from Open Exchange File
 * 	- Wiki: export model to Open Exchange File
 * 		- prefix all foldernames with the string _imported_
 * 	- Archi: import model from Open Exchange File
 * 	- Archi: save model in .archimate file
 * 	- Archi: import Another model into the selected Model
 * 	- now run this script to 
 * 		- move all synchronized objects back from the _imported_ folders to their original folders
 * 		- if there is no original folder, rename the folder by removing the prefix _imported_
 * 		- delete all empty _imported_ folders
 */
console.clear();
console.log()

const prefix = '_imported_'

let nrFoldersStart = $(model).find('folder').size()
console.log(`Number of folders is ${nrFoldersStart}\n`)

mergeImportedFolders($(model).first())

let nrFoldersRemaining = $(model).find('folder').size()

console.log()
console.log(`Merged ${nrFoldersStart - nrFoldersRemaining} folders with prefix ${prefix} of total of ${nrFoldersStart} folders`)
console.log(`${nrFoldersRemaining} folders remaining`)


/**
 * mergeImportedFolders()
 * 	recursive function to traverse the folder tree
 * 		move all objects from the imported folder to original folder
 * 		remove of rename imported folders
 * 
 * @param pImportedFolder 	current imported folder
 * @param pOriginalParent 	current parent where original folder can be found
 * @param pLevel 			current recursion level
 */
function mergeImportedFolders(pImportedFolder, pOriginalParent, pLevel = 0) {
	let importedSubFolders
	let originalParent
	let originalFolder

	console.log(`${"   ".repeat(pLevel)}${pImportedFolder.name}`)

	if (pLevel == 0) { 
		// get the Archi default folders in the root
		importedSubFolders = $(pImportedFolder).children("folder") 
	} else {
		// get all imported folders where name starts with prefix
		importedSubFolders = $(pImportedFolder).children("folder").filter(isImported) 

		// get parent folder of the original folder
		if (pOriginalParent != null) {
			originalParent = pOriginalParent
		} else {
			originalParent = $(pImportedFolder).parent("folder").first()
		}
		// find the original folder
		originalFoldersColl = $(originalParent).children("folder").filter(function (f) {
			return (f.name == pImportedFolder.name.substr(prefix.length))
		})
		if (originalFoldersColl.size() > 1) {
			throw (`Multiple possible original folders for ${pObject.name}`)
		}
		originalFolder = originalFoldersColl.first()

		// move all objects from the imported folder to original folder
		if (originalFolder != null) {
			$(pImportedFolder).children().not("folder").each(function (o) {
				originalFolder.add(o);
				console.log(`${"   ".repeat(pLevel+1)}${o} moved`)
			})
		}
	}

	// stop if folder has no imported subfolders
	if (importedSubFolders.size() == 0) {
		return
	}

	importedSubFolders.each(function (f) {
		mergeImportedFolders(f, originalFolder, pLevel + 1)

		if (pLevel != 0) { 
			// remove of rename imported folders
			if ($(f).children().size() == 0) {
				console.log(`${"   ".repeat(pLevel+1)}remove ${f.name}`)
				f.delete()
			} else {
				console.log(`${"   ".repeat(pLevel+1)}rename ${f.name}`)
				// f.name = f.name.substr(prefix.length)
			}
		}
	})

}


/**
 * filter function isImported
 * 	return true if folder f starts with prefix
 * @param f a folder
 */
function isImported(f) { 
	if (f.name.startsWith(prefix)) {
		// console.log(`${"   ".repeat(pLevel)}Imported folder: ${f.name}`)
		return true
	}
	return false
}
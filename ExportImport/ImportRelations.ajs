/*
 * Import relations from CSV
 * 
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Export to CSV Script - https://gist.github.com/smileham/15c445b17a92bd6f5dc1508e573bcd8a
 * 
 * Version 1: Import from CSV
 *
 * (c) 2018 Steven Mileham
 * 
 * Mark Backer
 * Version 2: Added import of relations and properties
 * 
 * 	Inputformat of the relation CSV:
 *	- use the script "Export to CSV.ajs" to create a spreadsheet with all the columns
 * 	- first columns are defined in relationHeaderDef
 * 		- column 1 to 4 the jArchi relation attributes
 * 		- column 5 to 8 identification of the source element. 
 * 			- The source Object ID is a custom property for finding the element
 * 		- column 9 to 12 idem as source
 * 		- extra columns in the CSV are saved as relation properties 
 * 	The import script adds to each imported relation a property customlabel_ImportLog_property as a logline for future reference in the architecture model
 */


// Show output in the console
console.show();
console.clear();
var filepath = __FILE__.split("/");
var scriptName = filepath[filepath.length-1];

console.log(`Executing script "${scriptName}"...\n`);

load(__DIR__ + "IncludeExportImport.ajs");

var error = new Error();
var debug = false;
var info = true;

var NrRelationUpdated = 0;
var NrRelationCreated = 0;
var skippedRelation = [];
var NrRelationSkipped = 0;

/*
 * Import relations
 */
CSVtable = read_CSVdata("releation");

if (!CSVtable) {
	console.log("> No CSV with relations");
} else {
	console.log("> Import CSV \n");

	CSVheader = CSVtable.data[0];
	console.log("> CSVheader >  " + CSVheader);
	
	try {
		// all rows, but skip header
		for (var i_row=1; i_row<CSVtable.data.length; i_row++) {
			var relation = null;
			var row = [];
			var flagValidRelation=false;
			var ImportLog = { Text: "" };

			if (CSVtable.data[i_row].length>1) { // skip empty line

				debug?console.log(">> ======== " ):true;
				debug?console.log(">> CSVtable.data[" + i_row + "] >  " + CSVtable.data[i_row]):true;

				// all columns
				for (var j_col=0; j_col<CSVheader.length; j_col++) {
					var str ="";
					str = CSVtable.data[i_row][j_col];
					row[CSVheader[j_col]]=str.trim();
					debug? console.log(">>> CSVtable.data[" + i_row + "] >  " + CSVheader[j_col] + " = " + row[CSVheader[j_col]]) : true;
				}

				// Find relation with customlabel_ID_property.
				relation = FindObjectWithProperty("relation", customlabel_ID_property, row[customlabel_ID_property]);
				if (relation) { // relation found with customlabel_ID_property

					relation.prop(customlabel_ImportLog_property, ">> Updated at " + ImportDate + " via \"" + customlabel_ID_property + "\"");
					flagValidRelation=true;
					NrRelationUpdated++;

				} else { // Select the relation with the id.
					var selectID ="#" + row[relationHeaderDef["id"]];
					debug? console.log(">> Find relation with id == " + selectID) : true;

					relation = $(selectID);
					if (relation.is('relation')) { // if there is 1 relation

						relation.prop(customlabel_ImportLog_property, ">> Updated at " + ImportDate + " via \"ID\"");
						flagValidRelation=true;
						NrRelationUpdated++;

					} else { // create relation
						debug? console.log(">> Relation not found, try to create relation"):true;
						var source = null;
						var target = null;

						sourceResult = FindElement(relationHeaderDef["source customlabel_ID_property"], row[relationHeaderDef["source customlabel_ID_property"]],
							row[relationHeaderDef["source.id"]],
							row[relationHeaderDef["source.name"]], row[relationHeaderDef["source.type"]]);
						targetResult = FindElement(relationHeaderDef["target customlabel_ID_property"], row[relationHeaderDef["target customlabel_ID_property"]], 
							row[relationHeaderDef["target.id"]],
							row[relationHeaderDef["target.name"]], row[relationHeaderDef["target.type"]]);
						source = sourceResult.vElement;
						target = targetResult.vElement;
						

						if (!sourceResult.vElement || !targetResult.vElement) {
							skippedRelation[NrRelationSkipped]=row[relationHeaderDef["source.name"]];
							if (!sourceResult.vElement) {
								skippedRelation[NrRelationSkipped]+= " (missing)";
							}
							skippedRelation[NrRelationSkipped]+= " <= " + row[relationHeaderDef["type"]] + " => " + row[relationHeaderDef["target.name"]];
							if (!targetResult.vElement) {
								skippedRelation[NrRelationSkipped]+= " (missing)";
							}
							debug?console.log(">>>> Skipped relation " + NrRelationSkipped + " : " + skippedRelation[NrRelationSkipped]):true;
							NrRelationSkipped++;
							flagValidRelation=false;
						} else {
							flagValidRelation=true;
						}
			
						if (flagValidRelation) {
							relationName = row[relationHeaderDef["name"]] ? row[relationHeaderDef["name"]] : "";
							if (!row[relationHeaderDef["type"]] ) {
								throw "Relation without type";
							}

							info? console.log(">> Create relation: " + source + " <= " + row[relationHeaderDef["type"]] + " => " + target):true;
			
							relation = model.createRelationship(
								row[relationHeaderDef["type"]],
								relationName,
								// "",
								source,
								target);

							relation.prop(customlabel_ImportLog_property, ">> Created at " + ImportDate);
							NrRelationCreated++;
							debug? console.log(">> Relation notfound_created: " + relation ):true;
						}
					}
				}

				if (flagValidRelation) {

					console.log(">> Relation : " + relation + " > " + relation.source.name + " <-> " + relation.target.name);

					// import attributes defined in header
					var attribute_i=0;
					for (var label in relationHeaderDef) {
						if (label=="name" || label=="documentation" || label=="type"){ // only attributes of relation, other relationHeaderDef are from source or target
							relation[label] = row[relationHeaderDef[label]];
							debug?console.log(">>> Set attribute : " + label + " = " + row[relationHeaderDef[label]]):true;
						}
						attribute_i++; // count length of relationHeaderDef
					}
					// import all properties	
					for (var j_col=attribute_i; j_col<CSVheader.length; j_col++) {
					// skip empty headers and don't overwrite with previous exported customlabel_ImportLog_property property
						if (row[CSVheader[j_col]] && row[CSVheader[j_col]] != customlabel_ImportLog_property) { 
							relation.prop(CSVheader[j_col], row[CSVheader[j_col]]);
							debug?console.log(">>> Set property : " + CSVheader[j_col] + " = " + row[CSVheader[j_col]]):true;
						}
					}
				} else {
					debug?console.log(">> relation skipped :" +
						row[relationHeaderDef["source.name"]] + 
						" <-> " +
						row[relationHeaderDef["target.name"]] ):true;
				}
			} // next line
		}
		if (skippedRelation.length>0) {
			console.log(">>>> There are skipped relations: ");
			for (var s=0; s<skippedRelation.length; s++) {
				console.log("     - " + skippedRelation[s]);
			}
			debug?console.log(">> ======== " ):true;
		}
		console.log("");
		console.log("> Parsing Complete");
		console.log("");
		console.log(">> Statistics relations <");
		console.log(">>>> Relations skipped : " + skippedRelation.length);
		console.log(">>>> Relations updated : " + NrRelationUpdated);
		console.log(">>>> Relations created : " + NrRelationCreated);
	}
	catch (error) {
		console.log("> Error: " + error.message);
		console.log("> Error: " + error.stack);
		console.log("> Relation : " + relation);
	}
}
console.log(`Script "${scriptName}" finished\n`);
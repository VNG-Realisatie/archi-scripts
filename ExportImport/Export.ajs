/*
 * Export To CSV
 * 
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Import from CSV script - https://gist.github.com/smileham/1e57a5946235e780dee5a824f664aa3d
 * 
 * Version 1: Export to CSV
 * Version 1.1: Avoid duplicate concepts exported from diagram
 * Version 1.2: Fix missing properties
 * Version 2: Updated to export Relationships to additional CSV
 * Version 2.1: Added error check for View.
 *
 * (c) 2018 Steven Mileham
 * 
 * Mark Backer
 * Version 3: Added relationship properties and restructure
 *
 */
// Show output in the console
console.show();
console.clear();
var filePath = __FILE__.split("/");
var scriptName = filePath[filePath.length-1];

console.log(`Executing script "${scriptName}"...\n`);

load(__DIR__ + "../_lib/papaparse.min.js");
load(__DIR__ + "IncludeExportImport.ajs");

var objectIndexMap = [];
var elementDuplicate = [];
var elementDuplicate_i = 0;
var relationDuplicate = [];
var relationDuplicate_i = 0;

var elementData = [];
var relationData = [];

var debug = false;
var info = true;

var selectedView = $(selection).filter("archimate-diagram-model").first();
if (!selectedView) {
	console.log("> Please Select a View");
} else {
	console.log("> Starting CSV Export for " + selectedView);
	// Loop through all element occurrences on the diagram
	//	element.concept is the actual element

	$(selectedView).find("element").each(function(element) { 

		info? console.log(">> " + element.concept):true;

		try {
            if (objectIndexMap[element.concept.id]) {
				elementDuplicate[elementDuplicate_i] = element.concept; 
				debug? console.log("Multiple occurrences on view of element: ", elementDuplicate[elementDuplicate_i]):true;
				elementDuplicate_i++;
			} else { 
				objectIndexMap[element.concept.id]=true;
				

				var Row = new Object;
                // retrieve all defined header attributes
				for (var label in elementHeaderDef) {
					Row[elementHeaderDef[label]]		=element.concept[label];
				}

				export_properties(element.concept, Row, elementHeaderDef);

				elementData.push(Row);

				// Get all relationships of the element (not only the occurrences on the view)
                $(element.concept).outRels().each(function (relationship) { 
                    if (objectIndexMap[relationship.id]) { // cannot happen, prepared for selection of occurrences of relationships on view
						relationDuplicate[relationDuplicate_i] = relationship; 
						debug? console.log("Multiple occurrences on view of relation: ", relationDuplicate[relationDuplicate_i]):true;
						relationDuplicate_i++;
					} else {
						objectIndexMap[relationship.id]=true;
	
						info? console.log(`>>> ${relationship} ${relationship.source.name} <-> ${relationship.target.name}`):true;

						var Row = new Object;
						// Retrieve all defined header attributes and properties
						console.log(JSON.stringify(relationHeaderDef, null, 2));
						for (var label in relationHeaderDef) {
//							if (label=="id" || label=="name" || label=="documentation" || label=="type"){ 
//								Row[relationHeaderDef[label]]		=relationship[label];
console.log(`### label = ${label}`);
Row[relationHeaderDef[label]]		= eval(`relationship.${label}`);
console.log(`### Row[relationHeaderDef[${label}]] = ${Row[relationHeaderDef[label]]}`);
//							}
						}
						// Row[relationHeaderDef["source.id"]]			=relationship.source.id; // can't get this working in for loop
                        // Row[relationHeaderDef["source.name"]]		=relationship.source.name;
                        // Row[relationHeaderDef["source.type"]]		=relationship.source.type;
                        // Row[relationHeaderDef["target.id"]]			=relationship.target.id;
                        // Row[relationHeaderDef["target.name"]]		=relationship.target.name;
						// Row[relationHeaderDef["target.type"]]		=relationship.target.type;

						// Source = relationship.source;
						// Target = relationship.target;

						// Row[relationHeaderDef["source CustomID"]]	= Source.prop(label_ID_property);
						// Row[relationHeaderDef["target CustomID"]]	= Target.prop(label_ID_property);

						// debug? console.log(`>>>> Source ${Source} ${Source.prop(label_ID_property)}`):true;
						// debug? console.log(`>>>> Target ${Target} ${Target.prop(label_ID_property)}`):true;

						export_properties(relationship, Row, relationHeaderDef);

						relationData.push(Row);
                    }
                }); // each relation
            }
        }
        catch (error) {
			console.log(`> ${arguments.callee.name}(): ${typeof error.stack == 'undefined' ? error : error.stack}`);
        }
    }); // each element

	// skipped VisualElements objects
	console.log("");
	console.log("> Skipped diagram-objects (diagram-objects do not exist in de model tree)" );
	var diagramObjectTypes = ["diagram-model-note", "diagram-model-group", "diagram-model-connection", "diagram-model-image", "diagram-model-reference"];
	diagramObjectTypes.forEach(function(ObjectType) {
		$(selectedView).find(ObjectType).each(function(diagramObject) {
			if (ObjectType == "diagram-model-note") {
				console.log(">>> " + diagramObject + diagramObject.text);
			} else {
				console.log(">>> " + diagramObject);
			}
		});
	});
	stats_CSVdata("elements", elementDuplicate, elementHeaderDef, elementData);
	stats_CSVdata("relations", relationDuplicate, relationHeaderDef, relationData);

	console.log("==============");
	write_CSVdata("elements", elementHeaderDef, elementData, selectedView);
	write_CSVdata("relations", relationHeaderDef, relationData, selectedView);
	console.log("==============");
}
console.log(`Script "${scriptName}" finished\n`);
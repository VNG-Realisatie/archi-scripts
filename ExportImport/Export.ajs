/*
 * Export To CSV
 * 
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Import from CSV script - https://gist.github.com/smileham/1e57a5946235e780dee5a824f664aa3d
 * 
 * Version 1: Export to CSV
 * Version 1.1: Avoid duplicate concepts exported from diagram
 * Version 1.2: Fix missing properties
 * Version 2: Updated to export Relationships to additional CSV
 * Version 2.1: Added error check for View.
 *
 * (c) 2018 Steven Mileham
 * 
 * Mark Backer
 * Version 3: Added relationship properties and restructure
 *
 */

load(__DIR__ + "../lib/papaparse.min.js");
load(__DIR__ + "IncludeExportImport.ajs");

var objectIndexMap = [];
var elementDuplicate = [];
var elementDuplicate_i = 0;
var relationDuplicate = [];
var relationDuplicate_i = 0;

var elementData = [];
var relationData = [];

var debug = false;
var info = true;

// Show output in the console
console.show();
console.clear();
console.log("Executing " + __FILE__.substring(6) + " ...");

var selectedView = $(selection).filter("archimate-diagram-model").first();
if (!selectedView) {
	console.log("> Please Select a View");
} else {
	console.log("> Starting CSV Export for " + selectedView);
	// Loop through all element occurrences on the diagram
	//	element.concept is the actual element

	$(selectedView).find("element").each(function(element) { 

		info? console.log(">> " + element.concept):true;

		try {
            if (objectIndexMap[element.concept.id]) {
				elementDuplicate[elementDuplicate_i] = element.concept; 
				debug? console.log("Multiple occurrences on view of element: ", elementDuplicate[elementDuplicate_i]):true;
				elementDuplicate_i++;
			} else { 
				objectIndexMap[element.concept.id]=true;
				

				var Row = new Object;
                // retrieve all defined header attributes
				for (var label in elementHeaderDef) {
					Row[elementHeaderDef[label]]		=element.concept[label];
				}

				export_properties(element.concept, Row, elementHeaderDef);

				elementData.push(Row);

				// Get all relationships of the element (not only the occurrences on the view)
                $(element.concept).outRels().each(function (relationship) { 
                    if (objectIndexMap[relationship.id]) { // cannot happen, prepared for selection of occurrences of relationships on view
						relationDuplicate[relationDuplicate_i] = relationship; 
						debug? console.log("Multiple occurrences on view of relation: ", relationDuplicate[relationDuplicate_i]):true;
						relationDuplicate_i++;
					} else {
						objectIndexMap[relationship.id]=true;
	
						info? console.log(`>>> ${relationship} ${relationship.source.name} <-> ${relationship.target.name}`):true;

						var Row = new Object;
						// Retrieve all defined header attributes and properties
						for (var label in relationHeaderDef) {
							if (label=="id" || label=="name" || label=="documentation" || label=="type"){ 
								Row[relationHeaderDef[label]]		=relationship[label];
							}
						}
						Row[relationHeaderDef["source.id"]]			=relationship.source.id; // can't get this working in for loop
                        Row[relationHeaderDef["source.name"]]		=relationship.source.name;
                        Row[relationHeaderDef["source.type"]]		=relationship.source.type;
                        Row[relationHeaderDef["target.id"]]			=relationship.target.id;
                        Row[relationHeaderDef["target.name"]]		=relationship.target.name;
						Row[relationHeaderDef["target.type"]]		=relationship.target.type;

						Source = relationship.source;
						Target = relationship.target;

						Row[relationHeaderDef["source CustomID"]]	= Source.prop(customlabel_ID_property);
						Row[relationHeaderDef["target CustomID"]]	= Target.prop(customlabel_ID_property);

						debug? console.log(`>>>> Source ${Source} ${Source.prop(customlabel_ID_property)}`):true;
						debug? console.log(`>>>> Target ${Target} ${Target.prop(customlabel_ID_property)}`):true;

						export_properties(relationship, Row, relationHeaderDef);

						relationData.push(Row);
                    }
                }); // each relation
            }
        }
        catch (error) {
            console.log("> Ignoring: " + element);
            console.log("> Error: " +  error);
        }
    }); // each element

	// skipped VisualElements objects
	console.log("");
	console.log("> Skipped diagram-objects (diagram-objects do not exist in de model tree)" );
	var diagramObjectTypes = ["diagram-model-note", "diagram-model-group", "diagram-model-connection", "diagram-model-image", "diagram-model-reference"];
	diagramObjectTypes.forEach(function(ObjectType) {
		$(selectedView).find(ObjectType).each(function(diagramObject) {
			if (ObjectType == "diagram-model-note") {
				console.log(">>> " + diagramObject + diagramObject.text);
			} else {
				console.log(">>> " + diagramObject);
			}
		});
	});
	stats_CSVdata("elements", elementDuplicate, elementHeaderDef, elementData);
	stats_CSVdata("relations", relationDuplicate, relationHeaderDef, relationData);

	// Open a dialog to let the user choose where to save the generated file
    var defaultFileName = model.name ? model.name + "-" + selectedView.name + ".csv" : "Exported Model.csv"; // Default file name
	var ExportFileLocation = window.promptSaveFile({ title: "Export to CSV", filterExtensions: [ "*.csv" ], fileName: defaultFileName } );

	console.log("==============");
	write_CSVdata("elements", elementHeaderDef, elementData, ExportFileLocation);
	write_CSVdata("relations", relationHeaderDef, relationData, ExportFileLocation);
	console.log("==============");
	console.log("> Export to CSV finished");
}
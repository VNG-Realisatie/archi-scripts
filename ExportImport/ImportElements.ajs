/*
 * Import elements from CSV
 *
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Export to CSV Script - https://gist.github.com/smileham/15c445b17a92bd6f5dc1508e573bcd8a
 *
 * Version 1: Import from CSV
 *
 * (c) 2018 Steven Mileham
 *
 * Mark Backer
 * Version 2: Added finding existing elements with a custom "id" in a property.
 *
 * - the label_ID_property is used for exchanging elements en relation between multiple architecture tools.
 * 	Inputformat of the relation CSV:
 *	- use the script "Export to CSV.ajs" to create a spreadsheet with all the columns
 * 	- first columns are defined in elementHeaderDef
 * 		- column 1 to 4 the jArchi relation attributes
 *	 	- extra columns in the CSV are saved as properties. The header label is used as the property name
 * 	The import script adds to each imported object a property customlabel_ImportLog_property as a logline for future reference in the architecture model
 */

load(__DIR__ + "IncludeExportImport.ajs");

var error = new Error();
var debug = false;
var info = true;

var Stat = {
	flag: { processed: false, updated: false, notfound_created: false },
	nr: { processed: 0, updated: 0, notfound_created: 0 },
};

// Show output in the console
console.show();
console.clear();
var filepath = __FILE__.split("/");
var scriptName = filepath[filepath.length - 1];

console.log(`Executing script "${scriptName}"...\n`);

CSVtable = read_CSVdata();
if (!CSVtable) {
	console.log("> Canceled, no CSV data ");
} else {
	console.log("> Import CSV");

	CSVheader = CSVtable.data[0];
	debug ? console.log("> CSVheader: " + CSVheader) : true;

	try {
		// skip header, read all rows
		for (var i_row = 1; i_row < CSVtable.data.length; i_row++) {
			var element = null;
			var CSVrow = [];
			var ImportLog = { Text: "" };
			Stat.flag.updated = false;
			Stat.flag.notfound_created = false;

			if (CSVtable.data[i_row].length > 1) {
				// skip empty line

				debug ? console.log(`>> CSVtable.data[${i_row}] >  ${CSVtable.data[i_row]}`) : true;
				debug ? console.log(">> ======== ") : true;

				// label CSVrow of i_row with headerlabel
				for (var j_col = 0; j_col < CSVheader.length; j_col++) {
					CSVrow[CSVheader[j_col]] = CSVtable.data[i_row][j_col].trim();
					debug ? console.log(`>>> CSVtable.data[${i_row}] > ${CSVheader[j_col]} = ${CSVrow[CSVheader[j_col]]}`) : true;
				}

				result = FindElement(
					label_ID_property,
					CSVrow[label_ID_property],
					CSVrow[elementHeaderDef["id"]],
					CSVrow[elementHeaderDef["name"]],
					CSVrow[elementHeaderDef["type"]]
				);

				if (result.vElement) {
					element = result.vElement;
					ImportLog.Text = `(Found ${result.vFindImportText})`;
				} else {
					debug
						? console.log(`>> Create element : ${CSVrow[elementHeaderDef["type"]]} ${CSVrow[elementHeaderDef["name"]]}`)
						: true;
					element = model.createElement(CSVrow[elementHeaderDef["type"]], CSVrow[elementHeaderDef["name"]]);
					ImportLog.Text = `(Created at ${ImportDate})`;
					Stat.flag.notfound_created = true;
				}

				import_attributes_properties(element, elementHeaderDef, CSVheader, CSVrow, Stat, ImportLog);
			}
		} // next line
		console.log("\n>> ======== ");
		console.log(">> Import finished");
		console.log(">>> elements processed : " + Stat.nr.processed);
		console.log(">>> elements updated   : " + Stat.nr.updated);
		console.log(">>> elements created   : " + Stat.nr.notfound_created);
		console.log("");
	} catch (error) {
		console.log("> Error: " + error);
		console.log("> Error: " + error.stack);
	}
}
console.log(`Script "${scriptName}" finished\n`);

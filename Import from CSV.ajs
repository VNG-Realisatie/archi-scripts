/*
 * Import from CSV
 * 
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Export to CSV Script - https://gist.github.com/smileham/15c445b17a92bd6f5dc1508e573bcd8a
 * 
 * Version 1: Import from CSV
 *
 * (c) 2018 Steven Mileham
 * 
 * Mark Backer
 * Version 2: Added import of relations and properties
 *
 */

load(__DIR__ + "lib/papaparse.min.js");
load(__DIR__ + "common/Export-import to CSV.ajs");

var debug = true;
var info = true;

var ImportDate  = new Date().toLocaleDateString();

console.show();
console.clear();
console.log("> Import CSV");

if (elementCSVData = read_CSVdata("element")) {

	elementParsedData = Papa.parse(elementCSVData);

	ParsedDataHeaders = elementParsedData.data[0];
	console.log("> ParsedDataHeaders: " + ParsedDataHeaders);
	
	try {
		// skip header, read all rows
		for (var i_row=1; i_row<elementParsedData.data.length; i_row++) {
			var labeledCell = [];

			debug?console.log("> elementParsedData.data[i_row]: " + elementParsedData.data[i_row]):true;

			// label cell of i_row with headerlabel
			for (var j_col=0; j_col<ParsedDataHeaders.length; j_col++) {
				labeledCell[ParsedDataHeaders[j_col]]=elementParsedData.data[i_row][j_col];
				debug? console.log(">> elementParsedData row " + i_row + " > " + ParsedDataHeaders[j_col] + " = " + labeledCell[ParsedDataHeaders[j_col]]) : true;
			}

			result = findCSVelement(labeledCell, "Object ID", elementMappings["id"], elementMappings["name"]);

			debug?console.log(">> result from findCSVelement : " + result.vImportKey + " : " + result.vElement):true;

			if (result.vImportKey == "Not found") {
				element = model.createElement(labeledCell[elementMappings["type"]], labeledCell[elementMappings["name"]]);
				element.prop("ImportAction", "Created");
			} else {
				element = result.vElement;
				element.prop("ImportAction", result.vImportKey);
			}
			console.log(">> " + element.prop("ImportAction") + " : " + element);
			debug?console.log(">> ======== " ):true;

			element.name			=labeledCell[elementMappings["name"]];
			element.documentation	=labeledCell[elementMappings["documentation"]];
			element.type			=labeledCell[elementMappings["type"]];
			// import all properties	
			for (var j_col=elementHeaders.length; j_col<ParsedDataHeaders.length; j_col++) {
				if (labeledCell[ParsedDataHeaders[j_col]]) {
					element.prop(ParsedDataHeaders[j_col],labeledCell[ParsedDataHeaders[j_col]]);
				}
			}
			element.prop("ImportDate", ImportDate);
		}
		console.log("> Parsing Complete")
	}
	catch (error) {
		console.log("> Error: " + error);
	}
} else {
	console.log("> No CSV with elements");
}

/*
 * Import relations
 */
 if (relationCSVData = read_CSVdata("releationship")) {

	relationParsedData = Papa.parse(relationCSVData);

	ParsedDataHeaders = relationParsedData.data[0];
	console.log("> ParsedDataHeaders: " + ParsedDataHeaders);
	
	debug=true;

	try {
		// all rows, but skip header
		for (var i_row=1; i_row<relationParsedData.data.length; i_row++) {
			var relationship = null;
			var labeledCell = [];

			console.log("> relationParsedData.data[i_row]: " + relationParsedData.data[i_row]);

			// all columns
			for (var j_col=0; j_col<ParsedDataHeaders.length; j_col++) {
				labeledCell[ParsedDataHeaders[j_col]]=relationParsedData.data[i_row][j_col];
				debug? console.log(">> relationParsedData row " + i_row + " > " + relationParsedData.data[0][j_col] + " = " + relationParsedData.data[i_row][j_col]) : true;
			}

			// Select the relationship with GEMMA Object id.
			debug? console.log(">> Find relation with Object ID == " + labeledCell["Object ID"]) : true;
			relationship = ObjectPropertyFind("relationship", "Object ID", labeledCell["Object ID"]);

			if (!relationship) { // if there is no relationship with the GEMMA Object ID
				// Select the relationship with the id.
				var selectID ="#" + labeledCell[relationshipMappings["id"]];
				debug? console.log(">> No relationship with Object ID, select relationship with id == " + selectID) : true;
				relationship = $(selectID);

				if (!relationship||relationship.length<1) { // if there is no relationship with the id. Test length, object is not null??
					info? console.log(">> Relationship not found, creating relationship"):true;
					var source = null;
					var target = null;

					sourceResult = findCSVelement(labeledCell, "Source Object ID", "Source ID", "Source label");
					targetResult = findCSVelement(labeledCell, "Target Object ID", "Target ID", "Target label");

					if (sourceResult.vImportKey == "Not found") {
						console.log(">> Error: source not found : " + element);
					} else {
						source = sourceResult.element;
						info?console.log(">> Source " + source.prop("ImportAction") + " : " + source):true;
					}
					if (targetResult.vImportKey == "Not found") {
						console.log(">> Error: target not found : " + element);
					} else {
						target = targetResult.element;
						info?console.log(">> target " + target.prop("ImportAction") + " : " + target):true;
					}
					debug?console.log(">> ======== " ):true;
		
					if (source && target) {
						relationship = model.createRelationship(
							labeledCell[relationshipMappings["type"]],
							labeledCell[relationshipMappings["name"]],
							source,
							target);
							
						relationship.prop("ImportAction", "Created");
					}
				} else {
					relationship.prop("ImportAction", "Updated by ID");
				}
			} else {
				relationship.prop("ImportAction", "Updated by Object ID");
			}
			info? console.log(">> relationship : " + relationship):true;

			relationship.name			=labeledCell[relationshipMappings["name"]];
			relationship.documentation	=labeledCell[relationshipMappings["documentation"]];
			relationship.type			=labeledCell[relationshipMappings["type"]];

			for (var j_col=elementHeaders.length; j_col<ParsedDataHeaders.length; j_col++) {
				if (labeledCell[ParsedDataHeaders[j_col]]) {
					relationship.prop(ParsedDataHeaders[j_col],labeledCell[ParsedDataHeaders[j_col]]);
				}
			}
			relationship.prop("ImportDate", ImportDate);
			console.log("> Parsing Complete")
		}
	}
	catch (error) {
		console.log("> Error: " + error.message);
		console.log("> Relationship : " + relationship);
	}
} else {
	console.log("> No CSV with relations");
}

/**
 * searchIDinModels.ajs
 *  Loop over all opened models and show objects with given id.
 */

load(__DIR__ + "Common/Common.ajs");

initConsoleLog(__FILE__)

promptText = `Find concept with id or Object ID`
var id = window.prompt(promptText, 'Enter id or Object ID')

// id = '95ff8a41-a3b6-4a14-bf66-3c7a52952a23'
try {

	if (id) {
		var loadedModelsList = $.model.getLoadedModels();
		var tableArray = [];

		tableArray.push(['Model', 'Object', 'id', 'Object ID']);

		for (let i = 0; i < loadedModelsList.length; i++) {
			let id_in_model = false;
			let loadedModel = loadedModelsList[i];
			loadedModel.setAsCurrent();

			$('*').each(function (object) {
				if ((object.id === id) || (object.prop('Object ID') === id)) {
					tableArray.push([model.name, object, object.id, object.prop('Object ID')]);
					id_in_model = true;
				}
			})
			if (!id_in_model) {
				tableArray.push([model.name, 'id not found','', '']);
			}
		}
		let t=table(tableArray, {markdown: true})
		console.log(t)
	} else {
		console.log('Cancelled');
	}
} catch (error) {
	console.log("> Error: " + error);
	console.log("> Stack: " + error.stack);
}

finishConsoleLog()

/**
 * function table
 * 	generate text table strings suitable for printing to stdout
 * 	usage: var s = table(rows, opts={})
 * 	
 *  based on https://www.npmjs.com/package/text-table
 * 
 * @param pRows 2 dimensional array with rows and columns
 * @param opts object with layout options
 * 
 * options are
 * 	opts.markdown   - generate a markdown table
 * 	opts.hsep       - separator to use between columns, default '  '
 * 	opts.align      - array of alignment types for each column, default ['l','l',...]
 *  opts.stringLength - callback function to use when calculating the string length
 * 
 * 	alignment types are:
 *     'l' - left
 *     'r' - right
 *     'c' - center
 *     '.' - decimal
 */
function table(pRows, opts) {
    const cLineChar = '-';
    const cIndexTitle = 1;
    const cIndexLine = 2;

    if (!opts) opts = {};
    var markDown = opts.markdown === true ? true : false;
    if (markDown) {
        var hsep = ' | ';
    } else {
        var hsep = opts.hsep === undefined ? '  ' : opts.hsep;
    }
    var align = opts.align || [];
    var stringLength = opts.stringLength || function (s) { return String(s).length; };

    // if option markdown is set, create and insert a row with the markdown title separator
    var rows_ = [];
    if (markDown) {
        var i_rowsTitle = 0;
        for (let i_row = 0; i_row < pRows.length; i_row++) {
            rows_[i_rowsTitle] = pRows[i_row];
            i_rowsTitle++;
            if (i_row == 0) {
                rows_[i_rowsTitle] = [];
                for (let i_cell = 0; i_cell < pRows[i_row].length; i_cell++) {
                    rows_[i_rowsTitle][i_cell] = cLineChar;
                }
                i_rowsTitle++;
            }
        }
    } else {
        rows_ = pRows;
    }
    
    var dotsizes = reduce(rows_, function (acc, row) {
        forEach(row, function (c, ix) {
            let n = dotindex(c);
            if (!acc[ix] || n > acc[ix]) acc[ix] = n;
        });
        return acc;
    }, []);
    
    // for collumns with '.', find the dot and fill out to the right
    var irow = 0;
    var rows = map(rows_, function (row) {
        irow++;
        return  map(row, function (c_, ix) {
            let c = String(c_);
            if (align[ix] === '.' && 
                (!markDown || // there is no title
                    (markDown && (irow != cIndexTitle && irow != cIndexLine)) // skip the Title rows
                ) 
                ) { 
                let index = dotindex(c);
                let size = dotsizes[ix] + (/\./.test(c) ? -1 : 0) - (stringLength(c) - index);

                return c + Array(size).join(' ');
            }
            else return c;
        });
    });
    
    var sizes = reduce(rows, function (acc, row) {
        forEach(row, function (c, ix) {
            let n = stringLength(c);
            if (!acc[ix] || n > acc[ix]) acc[ix] = n;
        });
        return acc;
    }, []);

    var irow = 0;
    var tableString = map(rows, function (row) {
        irow++;
        return `${markDown ? '| ' : ''}` + map(row, function (c, ix) {
            let n = (sizes[ix] - stringLength(c)) || 0;
            let s = Array(Math.max(n + 1, 1)).join(' ');
            if (markDown && irow == cIndexLine)  {
                return c + Array(Math.max(n + 1, 1)).join(cLineChar);
            }
            if ((align[ix] === 'c') || (markDown && irow == cIndexTitle)) {
                return Array(Math.ceil(n / 2 + 1)).join(' ')
                    + c + Array(Math.floor(n / 2 + 1)).join(' ');
            }
            if (align[ix] === 'r' || align[ix] === '.') {
                return s + c;
            }
            return c + s;
        }).join(hsep) //.replace(/\s+$/, '');
    }).join(`${markDown ? ' |' : ''}\n`);
    return tableString + `${markDown ? ' |' : ''}\n`;
};

function dotindex (c) {
    let m = /\.[^.]*$/.exec(c);
    return m ? m.index + 1 : c.length;
}

function reduce (xs, f, init) {
    if (xs.reduce) return xs.reduce(f, init);
    let i = 0;
    let acc = arguments.length >= 3 ? init : xs[i++];
    for (; i < xs.length; i++) {
        f(acc, xs[i], i);
    }
    return acc;
}

function forEach (xs, f) {
    if (xs.forEach) return xs.forEach(f);
    for (let i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
    }
}

function map (xs, f) {
    if (xs.map) return xs.map(f);
    let res = [];
    for (let i = 0; i < xs.length; i++) {
        res.push(f.call(xs, xs[i], i));
    }
    return res;
}
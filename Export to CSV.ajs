/*
 * Export To CSV
 * 
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Import from CSV script - https://gist.github.com/smileham/1e57a5946235e780dee5a824f664aa3d
 * 
 * Version 1: Export to CSV
 * Version 1.1: Avoid duplicate concepts exported from diagram
 * Version 1.2: Fix missing properties
 * Version 2: Updated to export Relationships to additional CSV
 * Version 2.1: Added error check for View.
 *
 * (c) 2018 Steven Mileham
 * 
 * Mark Backer
 * Version 3: Added relationship properties and restructure
 *
 */

load(__DIR__ + "lib/papaparse.min.js");
load(__DIR__ + "common/Export-import to CSV.ajs");

var objectIndexMap = [];
var elementDuplicate = [];
var elementDuplicate_i = 0;
var relationDuplicate = [];
var relationDuplicate_i = 0;

var elementData = [];
var relationData = [];

var debug = false;
var info = false;

// Show output in the console
console.show();
console.clear();
console.log("Executing " + __FILE__.substring(6) + " ...");

var selectedView = $(selection).filter("archimate-diagram-model").first();
if (!selectedView) {
	console.log("> Please Select a View");
} else {
	console.log("> Starting CSV Export for " + selectedView);
	// Loop through all element occurrences on the diagram
	//	element.concept is the actual element

	$(selectedView).find("element").each(function(element) { 

		info? console.log(">> " + element.concept):true;

		try {
            if (objectIndexMap[element.concept.id]) {
				elementDuplicate[elementDuplicate_i] = element.concept; 
				debug? console.log("Multiple occurrences on view of element: ", elementDuplicate[elementDuplicate_i]):true;
				elementDuplicate_i++;
			} else { 
				objectIndexMap[element.concept.id]=true;
				
				var Row = new Object;
                // retrieve all defined header attributes
				for (var label in elementHeaderDef) {
					Row[elementHeaderDef[label]]		=element.concept[label];
				}
                // retrieve all properties of the element
                for (var i=0; i<element.concept.prop().length; i++){
                    var PropertyLabel = element.concept.prop()[i];

                    if (element.concept.prop(PropertyLabel)) {
                        var found = false;

						for (var prop in elementHeaderDef) {
                            if (prop==PropertyLabel) {found=true;}            
                        }
                        if (!found) { // add property label only once to the header
                            elementHeaderDef[PropertyLabel] = PropertyLabel;
                            debug? console.log(">>> Add property label : " + PropertyLabel):true;
                        }
						Row[PropertyLabel] = element.concept.prop(PropertyLabel);
						debug? console.log(`>>>> Add property ${PropertyLabel} : ${element.concept.prop(PropertyLabel)}`):true;
                    }
                }

                elementData.push(Row);

                // Get all relationships of the element (not only the occurrences on the view)
                $(element.concept).outRels().each(function (relationship) { 
                    if (objectIndexMap[relationship.id]) { // cannot happen, prepared for selection of occurrences of relationships on view
						relationDuplicate[relationDuplicate_i] = relationship; 
						debug? console.log("Multiple occurrences on view of relation: ", relationDuplicate[relationDuplicate_i]):true;
						relationDuplicate_i++;
					} else {
						objectIndexMap[relationship.id]=true;
	
						info? console.log(`>>> ${relationship} ${relationship.source.name} <-> ${relationship.target.name}`):true;

						var Row = new Object;
						// Retrieve all defined header attributes and properties
						for (var label in relationHeaderDef) {
							if (label=="id" || label=="name" || label=="documentation" || label=="type"){ // how to make this work for all headerDefs???
								Row[relationHeaderDef[label]]		=relationship[label];
							}
						}
						Row[relationHeaderDef["source.id"]]			=relationship.source.id;
                        Row[relationHeaderDef["source.name"]]		=relationship.source.name;
                        Row[relationHeaderDef["source.type"]]		=relationship.source.type;
						Row[relationHeaderDef["source customID"]]	=relationship.source.prop(CustomIDproperty);
                        Row[relationHeaderDef["target.id"]]			=relationship.target.id;
                        Row[relationHeaderDef["target.name"]]		=relationship.target.name;
						Row[relationHeaderDef["target.type"]]		=relationship.target.type;
						Row[relationHeaderDef["target customID"]]	=relationship.target.prop(CustomIDproperty);
						
						// Retrieve all properties of the relation
                        for (var i=0; i<relationship.prop().length; i++){
							var PropertyLabel = relationship.prop()[i];
							
                            if (relationship.prop(PropertyLabel)) { // skip empty labels
                                var found = false;
								for (var prop in relationHeaderDef) { 
									if (prop==PropertyLabel) {found=true;}            
								}
                                if (!found) { // add property label to the header only once
									relationHeaderDef[PropertyLabel] = PropertyLabel;
									debug? console.log(">>>> Add property label : " + PropertyLabel):true;
                                }
                                Row[PropertyLabel] = relationship.prop(PropertyLabel);
								debug? console.log(">>>>> Add property " + PropertyLabel + ": " + relationship.prop(PropertyLabel)):true;
                            }
                        }
						
                        relationData.push(Row);
                    }
                }); // each relation
            }
        }
        catch (error) {
            console.log("> Ignoring: " + element);
            console.log("> Error: " +  error);
        }
    }); // each element

	// skipped VisualElements objects
	console.log("");
	console.log("> Skipped diagram-objects (diagram-objects do not exist in de model tree)" );
	var diagramObjectTypes = ["diagram-model-note", "diagram-model-group", "diagram-model-connection", "diagram-model-image", "diagram-model-reference"];
	diagramObjectTypes.forEach(function(ObjectType) {
		$(selectedView).find(ObjectType).each(function(diagramObject) {
			if (ObjectType == "diagram-model-note") {
				console.log(">>> " + diagramObject + diagramObject.text);
			} else {
				console.log(">>> " + diagramObject);
			}
		});
	});
	stats_CSVdata("elements", elementDuplicate, elementHeaderDef, elementData);
	stats_CSVdata("relations", relationDuplicate, relationHeaderDef, relationData);

	// Open a dialog to let the user choose where to save the generated file
    var defaultFileName = model.name ? model.name + "-" + selectedView.name + ".csv" : "Exported Model.csv"; // Default file name
	var ExportFileLocation = window.promptSaveFile({ title: "Export to CSV", filterExtensions: [ "*.csv" ], fileName: defaultFileName } );

	console.log("==============");
	write_CSVdata("elements", elementHeaderDef, elementData, ExportFileLocation);
	write_CSVdata("relations", relationHeaderDef, relationData, ExportFileLocation);
	console.log("==============");
	console.log("> Export to CSV finished");
}
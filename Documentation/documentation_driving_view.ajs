/**
 *  documentation_driving_view.ajs
 * 
 * 	Purpose: To generate architecture output in markdown format based on a driving view
	Note - markdown can be converted to PDF / Word Docs or anything. 

	Original idea and script from Richard Heward - Tame Blue Lion Ltd
	See blog for a more detailed explaination. https://www.tamebluelion.co.uk/archimate-documentation

	The driving view defines the structure of the documentation. 
	You define the structure of the documentation by visualy drawing it. 
	Draw a group to create a sections. Embed a view references in the group to print it there. 

	You can use the following elements to define your document structure
	- visual group or a grouping (use groupings if they have meaning in your model, else use visual groups)
		- a group becomes a section. You can embed groupings to create subsections.
		- the group name is the section title, the group documentation is printed below the title
	- note
		- the content of the note is printed
	- view reference
		- the view is printed (archimate or sketch view)
		- for archimate views a table with all the elements of the view is printed

	Set some properties of the driving view to change the default behavior of the script
	Just run the script and see in the console the properties you can use.

	Created: 8-Oct-2019

	Mark Backer
	- Structured to own liking
	- Follow structure of drivingView left to right and top to bottom like reading (no need for triggering relations)
	- Output view elements in a hierarchic HTML table
	- Option to output a table with all elements of all views
	- 
 * 
 */

load(__DIR__ + "../Common/Common.ajs");
load(__DIR__ + "includeDocumentation.ajs");

console.clear();
initConsoleLog(__FILE__)

try {
	var document = new Object();
	var documentSettings = new Object();

	var drivingView = selection.filter("archimate-diagram-model").first();

	if (drivingView) {
		init(documentSettings)

		if (documentSettings.drivingView.value) {

			console.log(`Driving view is: ${drivingView.name}\n`);

			let exportFile = '';
			let fileName = `${new Date().toLocaleDateString('nl-NL')} ${drivingView.name}.md`

			// to skip the popup window while debugging, set path as a property
			if (documentSettings.path.value) {
				exportFile = `${documentSettings.path.value}${slash()}${fileName}`
			} else {
				exportFile = window.promptSaveFile({
					title: "Export to File",
					filterExtensions: ["*.md"],
					fileName: fileName
				});
			}

			if (exportFile) {

				console.log(`Processing drivingView '${drivingView.name}'`);
				
				// Initialize document object
				document.content = "---\n";
				document.content += '# Content\n\n';
				document.body = '';
				
				// First level is a view, not an element > start with level = 0. 
				documentStructure(0, '', drivingView, exportFile);
				
				if (documentSettings.includeTableOfAllViews.value) {
					documentTableOfAllViews()
				}
				
				console.log(`\nMarkdown report saved to:`);
				console.log(`- path:     ${exportFile.substring(0, exportFile.lastIndexOf(slash()))}`);
				console.log(`- fileName: ${exportFile.substring(exportFile.lastIndexOf(slash()) + 1)}`);
				
				let documentString = documentFirstPage(documentSettings)
				documentString += document.content
				documentString += document.body;
				$.fs.writeFile(exportFile, documentString);

				finishConsoleLog()
			} else {
				console.log("Canceled")
			}
		} else {
			// document current view ### todo
			// pop up You want to document the current view?
			// header view.name
			// embedded view
			// hierarchic table
			console.log(`The selected view '${drivingView.name}' is not a valid drivingView.`)
			console.log(`A drivingView must have a property 'drivingView' with the value 'true'`)
		}
	} else {
		console.log("Please open and select a Driving View");
	}
} catch (error) {
	console.log(`> ${typeof error.stack == 'undefined' ? error : error.stack}`);
}

/**
 * Read document settings from drivingView properties
 * Generate first page
 */
function init(documentSettings) {
	
	documentSettings.drivingView = {
		value: null,
		description: `A drivingView must have this property (true)`
	}
	documentSettings.includeTableOfView = {
		value: true,
		description: `Print below every view the elements (true/false)`
	}
	documentSettings.includeTableOfAllViews = {
		value: false,
		description: `Print all elements at the end of document (true/false)`
	}
	documentSettings.renderViewScale = {
		value: 1,
		description: `Resolution of generated images (1 to 4)`
	}
	documentSettings.renderViewEmbed = {
		value: true,
		description: `Embed images or generate .png files (true/false)`
	}
	documentSettings.paragraphNumber = {
		value: false,
		description: `Generate paragraph numbers (true/false)`
	}
	documentSettings.path = {
		value: null,
		description: `Path for saving markdown (pop-up if not set)`
	}
	documentSettings.author = {
		value: '',
		description: 'Name of author'
	}
	documentSettings.organisation = {
		value: '',
		description: 'Name of organisation'
	}

	// set documentSettings with the driving view properties
	getObjectProperties(drivingView, documentSettings)
}

/**
 * Generate first page
 */
function documentFirstPage(pSettingObject) {

	let markdownString = `# ${drivingView.name}\n`;
	markdownString += (drivingView.documentation) ? `${drivingView.documentation}\n` : ''

	markdownString += `${pSettingObject.author.value}\n`;
	markdownString += `${pSettingObject.organisation.value}\n`;
	markdownString += `Document generated at: ${new Date().toLocaleDateString('nl-NL')}  ${new Date().toLocaleTimeString('nl-NL')}\n\n`;

	return markdownString
}

/**
 * getObjectProperties
 * 	read the properties of the driving view as settings
 * 	show the properties in the console in a table
 *  
 * @param pDrivingView driving view
 * @param pSettingObject settings
 */
function getObjectProperties(pDrivingView, pSettingObject) {
	let tableArray = [];
	tableArray.push(['drivingView property', 'Description', 'Default', 'Value']);

	for (var key in pSettingObject) {
		let defaultValue = pSettingObject[`${key}`]['value']
		defaultValue = defaultValue === null ? 'null' : defaultValue;
		let propValue = 'Not set'

		if (pDrivingView.prop(key) != null) {

			if (typeof pSettingObject[`${key}`]['value'] == 'boolean') {
				// pDrivingView.prop(key) == "true" ? pSettingObject[key] = true : pSettingObject[key] = false;
				pSettingObject[`${key}`]['value'] = (pDrivingView.prop(key) == "true");
			} else {
				pSettingObject[`${key}`]['value'] = pDrivingView.prop(key);
			}
			propValue = pDrivingView.prop(key)
		}

		// console.log(`- ${key}: ` + pSettingObject[`${key}`]['description'] + ' | ' + pSettingObject[`${key}`]['value'])

		tableArray.push([key, pSettingObject[`${key}`]['description'], defaultValue, propValue]);
	}

	console.log(table(tableArray, {
		markdown: true
	}))
	console.log()
}

/**
 * printObjectHeading
 * 	add the given object to the contentlist and create a heading
 * 	if the object has documentation, also create a paragraph
 * 
 * @param pLevel use recursion depth as paragraph level
 * @param pParagraphNr paragraph number for heading
 * @param pObject current group or view
 * @param pTypeText type of current object 
 */
function printHeadingAndDocumentation(pLevel, pParagraphNr, pObject, pTypeText) {

	// add optional paragraph number 
	let heading = documentSettings.paragraphNumber.value ? `${pParagraphNr} ` : '';
	heading += (pObject.type == "archimate-diagram-model") ? 'View ' : '';
	heading += (pObject.type == "canvas-model") ? 'Picture ' : '';
	heading += pObject.name;

	// add heading to content
	document.content += `${'\t'.repeat(pLevel - 1)}* [${heading}](${stringToLink(heading)})\n`;

	// insert heading in document
	if (pLevel == 1) {
		document.body += '<div style="page-break-before: always;"></div>';
		document.body += "\n\n---\n\n";
	}
	document.body += `${'#'.repeat(pLevel)} ${heading}\n\n`;

	// insert documentation of the object in document
	if (pObject.documentation != "") {
		document.body += `${pObject.documentation}\n\n`;
	}
	console.log(`${'>'.repeat(pLevel)} ${pObject.name} (${pTypeText})`);

	// create a valid anchor link for a heading
	function stringToLink(theString) {
		// this function thanks to Steven Mileham
		// remove these characters from a link '[]()#\".'
		var regex = /[\[\]\(\)\#\\\/\"\.]/gi;
		return "#" + theString.toLowerCase().replace(regex, "")
			.replaceAll(" ", "-")
			.replaceAll("\<", "lt")
			.replaceAll("\>", "gt");
	}
}

/**
 * documentStructure 
 * 	this recursive function reads the document structure from the driving view
 * 	-	follow the elements on the driving view from top left to the bottom right
 * 	-	recurse into groups with embedded elements/children
 * 		- print (visual) groups as sectionheaders
 * 		- print viewReferences
 * 		- print notes
 * 
 * @param pLevel 		number with recursion depth, used for logging and paragraph numbers
 * @param pParagraphNr 	string with paragraph number
 * @param pObject 		visual object to traverse, start with drivingView
 */
function documentStructure(pLevel, pParagraphNr, pObject, pExportFile) {

	// scope of childArray is this function and all recursions
	var childArray = [];

	// add text of note to the current paragraph in the report
	if (pObject.type == "diagram-model-note") {
		document.body += `${pObject.text}\n\n`;
		console.log(`${'>'.repeat(pLevel)} insert text from note`);
	} else {
		// add referenced view to the current paragraph in the report
		if (pObject.type == "diagram-model-reference" || // view reference not working or
			(pObject.type == "archimate-diagram-model" && pObject.view) || // "diagram-model-reference" work around
			(pObject.type == "canvas-model" && pObject.view) // canvas view
		) {

			printHeadingAndDocumentation(pLevel, pParagraphNr, pObject, 'view')

			// Print the view. 
			// Find the referenced view by looping over and comparing names ### comparing id's possible?
			$('view').each(function (view) {
				if (view.name == pObject.name) {
					document.body += printView(view, documentSettings.renderViewScale.value, documentSettings.renderViewEmbed.value, pExportFile);

					// Print a table with the views elements, if includeTableView is set.
					// "canvas-model" views don't have elements, so skip
					if (documentSettings.includeTableOfView && pObject.type != "canvas-model") {
						document.body += printElementsHierarchic(pLevel, view);
					}
				}
			});

		} else {

			// Check for subparagraphs and recurse into subparagraph
			if ((pObject.type == "archimate-diagram-model" && !pObject.view) || // driving view or 
				pObject.type == "diagram-model-group" || // visual group or
				pObject.type == "grouping") { // group

				// skip pLevel 0, this is the drivingview
				if (pLevel > 0) {
					printHeadingAndDocumentation(pLevel, pParagraphNr, pObject, 'group')
				}

				// console.log(`${">".repeat(pLevel+1)} ${pObject.name}`)
				// select all embedded (visual) elements. Skip relations
				let childrenCollection = $(`#${pObject.id}`).children().not("relation");

				// stop if element has no children
				if (childrenCollection.size() > 0) {

					// console.log(`${">".repeat(pLevel+1)} ${childrenCollection.size()} Children > ${childrenCollection}`)
					// console.log(`${">".repeat(pLevel)} ${childrenCollection.size()} Children`)

					childrenCollection.each(function (c) {
						childArray.push(c);
					})
					// Sort array of embedded children from left to right
					childArray.sort(sortPosition)

					for (let i = 0; i < childArray.length; i++) {
						documentStructure(pLevel + 1, `${pParagraphNr}${i + 1}.`, childArray[i], pExportFile);
					}
				};
			}
		}
	}
	return
}

/**
 * Generate page with TableOfAllViews
 */
function documentTableOfAllViews() {
	var lastTable = new Object();
	lastTable.name = 'Tabel met elementen van alle views';
	lastTable.documentation = '';

	printHeadingAndDocumentation(1, 'A.', lastTable, 'appendix')

	document.body += printTableOfAllViews(drivingView)
}

/**
 * printTableOfAllViews
 *  create a table with all elements of all views referenced in the driving view
 * 
 * @param pView drivingView with view references
 */
function printTableOfAllViews(pView) {
	var markdownTable = '';
	var allElements = [];

	let i = 0;
	// loop over all reference-views of the driving view
	$(pView).find("diagram-model-reference").each(function (viewReference) {
		// Find the actual linked views
		linkedView = $("view").filter(function (v) {
			return v.name === viewReference.name
		})
		linkedView.find("element").each(function (element) {
			allElements[i] = element;
			i++;
		})
	})
	// Sort array of found elements alphabetical
	allElements.sort(sortAlphabetic)

	markdownTable += `| Element | Type | Documentatie |\n`;
	markdownTable += `| ------- | -----|------------- |\n`;

	var uniqueRowSet = new Set();
	for (let j = 0; j < allElements.length; j++) {
		let e = allElements[j];
		let elementKey = `| ${e.name} (${e.type}) | ${e.documentation}|\n`
		if (!uniqueRowSet.has(elementKey)) {
			markdownTable += `| ${e.name} | ${e.type} | ${tableCell2HTML(e.documentation)}|\n`
		}
		uniqueRowSet.add(elementKey)
	}

	console.log(`>> number of elements on all views: ${allElements.length}`)
	console.log(`>> number of unique elements: ${uniqueRowSet.size}`)

	return markdownTable;

	function sortAlphabetic(a, b) {
		if (a.name.toLowerCase() < b.name.toLowerCase()) {
			return -1;
		}
		if (a.name.toLowerCase() > b.name.toLowerCase()) {
			return 1;
		}
		return 0;
	}
}
/**
 *  documentation_view_template.ajs
 * 
 */

load(__DIR__ + "../Common/Common.ajs");

console.clear();
initConsoleLog(__FILE__)

try {
	var document = new Object();
	var documentSettings = new Object();

	var drivingView = selection.filter("archimate-diagram-model").first();

	if (drivingView) {
		if (drivingView.prop("documentationDrivingView") != null) {

			console.log(`Driving view is: ${drivingView.name}\n`);

			if (init()) {

				documentFirstPage()
				// First level is a view, not an element > start with level = 0. 
				documentStructure(0, '', drivingView);
				documentLastTable()

				console.log(`Markdown report saved to:`);
				console.log(`- path:     ${documentSettings.path}`);
				console.log(`- fileName: ${documentSettings.fileName}`);

				let documentString = document.start + document.content + document.body;
				$.fs.writeFile(documentSettings.exportFile, documentString);

				finishConsoleLog()
			} else {
				console.log("Canceled")
			}
		} else {
			console.log(`Not a valid drivingView. Please add a property 'documentationDrivingView'`)
		}
	} else {
		console.log("Please open and select a Driving View");
	}
} catch (error) {
	console.log(`> ${typeof error.stack == 'undefined' ? error : error.stack}`);
}

/**
 * Read document settings from drivingView properties
 * Generate first page
 */
function init() {

	let exportFile = '';
	let datum = new Date();
	let fileName = `${datum.toLocaleDateString('nl-NL')} ${drivingView.name}.md`

	documentSettings.includeTableOfView = true;
	documentSettings.includeTableOfAllViews = false;
	documentSettings.renderViewScale = 2;
	documentSettings.renderViewEmbed = true;
	documentSettings.path = '';

	// set documentSettings with the driving view properties
	console.log(`Driving view settings: `)
	getObjectProperties(drivingView, documentSettings)

	// to skip the popup window while debugging, set path as a property
	if (documentSettings.path) {
		// fs.writefile seems to accept slashes and backslashes independent of platform??
		// if (slash() == "\\") {
		// 	documentSettings.path = documentSettings.path.replaceAll("/", "\\/");
		// } else {
		// 	documentSettings.path = documentSettings.path.replaceAll(/\\/g, "/");
		// }
		exportFile = `${documentSettings.path}${slash()}${fileName}`
	} else {
		exportFile = window.promptSaveFile({
			title: "Export to File",
			filterExtensions: ["*.md"],
			fileName: fileName
		});
	}
	if (exportFile) {
		documentSettings.path = exportFile.substring(0, exportFile.lastIndexOf(slash()) + 1);
		documentSettings.fileName = exportFile.substring(exportFile.lastIndexOf(slash()) + 1);
		documentSettings.exportFile = exportFile;
	}
	return exportFile

	function slash() {
		var System = Java.type("java.lang.System")
		var nameOS = System.getProperty("os.name", "");

		if (nameOS.indexOf("Win") != -1) {
			return "\\";
		} else {
			if ((nameOS.indexOf("Mac") != -1) ||
				(nameOS.indexOf("X11") != -1) ||
				(nameOS.indexOf("Linux") != -1)) {
				return "/";
			} else {
				throw (`>> Unknown OS: ${nameOS}`);
			}
		}
	}
}

/**
 * Generate first page
 */
function documentFirstPage() {

	document.start = `# ${drivingView.name}\n`;
	document.start += `${drivingView.documentation}\n\n`

	documentProperties = new Object()
	documentProperties.Author = ''
	documentProperties.Organisation = ''

	// set documentProperties with the driving view properties
	console.log(`Driving view document properties: `)
	getObjectProperties(drivingView, documentProperties)

	document.start += `${documentProperties.Author}\n`;
	document.start += `${documentProperties.Organisation}\n`;

	let datum = new Date();
	document.start += `Document generated at: ${datum.toLocaleDateString('nl-NL')}\n\n`;
	document.start += "\n---\n";

	// Initialize document.content
	document.content = '# Content\n\n';
	document.body = '\n\n';
}

function getObjectProperties(pObject, pProperty) {

	for (var key in pProperty) {
		if (pObject.prop(key) != null) {
			if (pProperty[key].type == Boolean) {
				pProperty[key] = (pObject.prop(key) === "true");
			} else {
				pProperty[key] = pObject.prop(key);
			}
		}
		console.log(`- ${key}: ${pProperty[key]}`)
	}
	console.log()
}

/**
 * Generate lastTable
 */
function documentLastTable() {
	if (documentSettings.includeTableOfAllViews) {
		var lastTable = new Object();
		lastTable.name = 'Tabel met elementen van alle views';
		lastTable.documentation = '';

		printObjectHeading(1, lastTable, 'String')

		document.body += printTableOfAllViews(drivingView)
	}
}

function printTableOfAllViews(pView) {
	var markdownTable = '';
	var allElements = [];

	let i = 0;
	// loop over all reference-views of the driving view
	$(pView).find("diagram-model-reference").each(function (viewReference) {
		// Find the actual linked views
		linkedView = $("view").filter(function (v) {
			return v.name === viewReference.name
		})
		linkedView.find("element").each(function (element) {
			allElements[i] = element;
			i++;
		})
	})
	// Sort array of found elements alphabetical
	allElements.sort(sortAlphabetic)

	markdownTable += `| Element | Type | Documentatie |\n`;
	markdownTable += `| ------- | -----|------------- |\n`;

	var uniqueRowSet = new Set();
	for (let j = 0; j < allElements.length; j++) {
		let e = allElements[j];
		let elementKey = `| ${e.name} (${e.type}) | ${e.documentation}|\n`
		if (!uniqueRowSet.has(elementKey)) {
			markdownTable += `| ${e.name} | ${e.type} | ${tableCell2HTML(e.documentation)}|\n`
		}
		uniqueRowSet.add(elementKey)
	}

	console.log('\nTable with all elements')
	console.log(`- number of elements on all views: ${allElements.length}`)
	console.log(`- number of unique elements: ${uniqueRowSet.size}\n`)

	return markdownTable;

	function sortAlphabetic(a, b) {
		if (a.name.toLowerCase() < b.name.toLowerCase()) {
			return -1;
		}
		if (a.name.toLowerCase() > b.name.toLowerCase()) {
			return 1;
		}
		return 0;
	}
}

/**
 * documentStructure 
 * 	this recursive function reads the document structure from the driving view
 * 	-	follow the elements on the driving view from top left to the bottom right
 * 	-	recurse into groups with embedded elements/children
 * 		- print (visual) groups as sectionheaders
 * 		- print viewReferences
 * 		- print notes
 * 
 * @param pLevel 		number with recursion depth
 * @param pParagraph 	string with paragraph number
 * @param pObject 		visual object to traverse, start with drivingView
 */
function documentStructure(pLevel, pParagraph, pObject) {

	// scope of childArray is this function and all recursions
	var childArray = [];

	// add text of note to the current paragraph in the report
	if (pObject.type == "diagram-model-note") {
		document.body += `${pObject.text}\n\n`;
		console.log(`${'>'.repeat(pLevel)} insert text from note`);
	} else {
		// bug in jArchi; visual object of type "diagram-model-reference" return type "archimate-diagram-model"
		// add referenced view to the current paragraph in the report
		if (pObject.type == "diagram-model-reference" || // view reference not working or
			(pObject.type == "archimate-diagram-model" && pObject.view) || // view reference work around or
			(pObject.type == "canvas-model" && pObject.view) // canvas view
		) {

			printObjectHeading(pLevel, pObject, 'view')

			// Find the actual referenced view; loop over all views and compare names
			$('view').each(function (view) {
				if (view.name == pObject.name) {

					printView(view);

					// if the property includeTableOfView is set, print a table with the views elements.
					// "canvas-model" views don't have elements, so skip
					if (documentSettings.includeTableOfView && pObject.type != "canvas-model") {
						printElementsHierarchic(pLevel, view);
					}
				}
			});

		} else {

			// Check for subparagraphs and recurse into subparagraph
			if ((pObject.type == "archimate-diagram-model" && !pObject.view) || // driving view or 
				pObject.type == "diagram-model-group" || // visual group or
				pObject.type == "grouping") { // group

				// skip pLevel 0, this is the drivingview
				if (pLevel > 0) {

					printObjectHeading(pLevel, pObject, 'group')
				}

				// console.log(`${">".repeat(pLevel+1)} ${pObject.name}`)
				// select all embedded (visual) elements. Skip relations
				let childrenCollection = $(`#${pObject.id}`).children().not("relation");

				// stop if element has no children
				if (childrenCollection.size() > 0) {

					// console.log(`${">".repeat(pLevel+1)} ${childrenCollection.size()} Children > ${childrenCollection}`)
					// console.log(`${">".repeat(pLevel)} ${childrenCollection.size()} Children`)

					let i = 0;
					childrenCollection.each(function (c) {
						childArray[i] = c
						i++;
					})
					// Sort array of embedded children from left to right
					childArray.sort(sortPosition)

					for (let i = 0; i < childArray.length; i++) {

						let paragraph = ``;

						// skip pLevel 0, this is the drivingview
						if (pLevel == 0) {
							paragraph = `${i + 1}`;
						} else {
							paragraph = `${pParagraph}.${i + 1}`
						}
						documentStructure(pLevel + 1, paragraph, childArray[i]);
					}
				};
			}
		}
	}
	return

	// render the view to a string
	// - embed in the document 
	// - or save as .png
	function printView(view) {

		let bytes = $.model.renderViewAsBase64(view, "PNG", {
			scale: documentSettings.renderViewScale,
			margin: documentSettings.renderViewScale * 10
		});

		if (documentSettings.renderViewEmbed) {
			document.body += `\n![${view.name}](data:image/png;base64,${bytes})\n`;
		} else {
			let imageFile = `${documentSettings.path}${view.name}.png`
			$.fs.writeFile(imageFile, bytes, "BASE64");

			let imageURL = imageFile.replaceAll(" ", "%20");
			document.body += `\n![${view.name}][${view.name}]`;
			document.body += `\n[${view.name}]: ${imageURL}`;
		}
		document.body += `\n<p align="center"><i>View ${view.name}</i></p>\n\n`;
	}
}

/**
 * printObjectHeading
 * 	add the given object to the contentlist and create a heading
 * 	if the object has documentation, also create a paragraph
 * 
 * @param pLevel use recursion depth as paragraph level
 * @param pObject current element
 * @param pTypeText type of current element 
 */
function printObjectHeading(pLevel, pObject, pTypeText) {

	console.log(`${'>'.repeat(pLevel)} ${pObject.name} (${pTypeText})`);

	// document.content += `${'#'.repeat(pLevel)} ${pObject.name}\n`;
	document.content += `${'\t'.repeat(pLevel - 1)}* [${pObject.name}](${stringToLink(pObject.name)}) \n`;

	if (pLevel == 1) {
		document.body += '<div style="page-break-before: always;"></div>';
		document.body += "\n\n---\n\n";
	}
	document.body += `${'#'.repeat(pLevel)} ${pObject.name}\n`;

	if (pObject.documentation != "") {
		document.body += `${pObject.documentation}\n\n`;
	}

	function stringToLink(theString) {
		// this function thanks to Steven Mileham
		var regex = /[\[\]\(\)\#\\\/\"]/gi;
		return "#" + theString.toLowerCase().replace(regex, "")
			.replaceAll(" ", "-")
			.replaceAll("\<", "lt")
			.replaceAll("\>", "gt");
	}
}

// document the elements (not relations) on the view
function printElementsHierarchic(pLogLevel, view) {
	// maxlevel is used to generate a table column for each level
	// start with level 0. Don't count the first level, this is the view
	var maxLevel = findMaxEmbedding(0, view);

	console.log(`${'>'.repeat(pLogLevel)} table with ${maxLevel} columns`)

	document.body += `<table>
	<thead>
		<tr>
			<th colspan="${maxLevel}" width="20%">Element</th>
			<th rowspan="2" width="80%">Documentation</th>
		</tr>
	</thead>
	<tbody>
		<tr >`;
	// for (let i = 1; i < maxLevel+1; i++) { document.body += `<td align="center">(${i})</td>` }
	// generate 'empty' columnheaders, this is ugly
	for (let i = 1; i < maxLevel + 1; i++) {
		document.body += `
			<td align="center"></td>`
	}
	document.body += `
			<td></td>
		</tr>`

	// write a Markdown table line for every child and the child's children
	// First level is a view, not an element > start with level = 0. 
	printTableRow(0, maxLevel, false, view);

	document.body += `	
	</tbody>
</table>\n\n`
	return

	// Private recursive function to find deepest level of embedding
	function findMaxEmbedding(level, pObject) {

		if ($(`#${pObject.id}`).children("element").size() == 0) {
			return level
		};

		let maxLevel = 0
		$(`#${pObject.id}`).children("element").each(function (c) {
			recurseLevel = findMaxEmbedding(level + 1, c);
			if (maxLevel < recurseLevel) {
				maxLevel = recurseLevel;
			}
		})
		return maxLevel
	}

	// Private recursive function for writing table row for current elements
	function printTableRow(pLevel, pMaxLevel, pChildLineIsWritten, pObject) {
		// scope of childArray is this function and all recursions
		var childArray = [];
		let i = 0;
		$(`#${pObject.id}`).children("element").each(function (c) {
			childArray[i] = c
			i++;
		})

		// Write table line for every visual child element of view and children
		if (pObject.type !== "archimate-diagram-model") {

			// Skip duplicate elements if element has no children
			if (!pChildLineIsWritten || childArray.length > 0) {

				document.body += `<tr valign="top")>`;
				// for (let i = 1; i < pLevel; i++) { document.body += `<td></td>` }
				if (pLevel > 1) {
					document.body += `
			<td colspan="${pLevel - 1}"></td>`
				}
				document.body += `
			<td colspan="${pMaxLevel - pLevel + 1}">${pObject.name}</td>
			<td>${tableCell2HTML(pObject.documentation)}</td>
		</tr>`

				// console.log(`${">".repeat(pLevel)} ${pObject.name}`)

			} else {
				console.log(`${">".repeat(pLogLevel+1)} Skip row for duplicate ${pObject.name}`)
			}
		}

		// stop if element has no children
		// if ($(`#${pObject.id}`).children("element").size() == 0) {
		if (childArray.length == 0) {
			return
		};

		// Sort array of embedded children from left to right
		childArray.sort(sortPosition)

		// set for checking if there are multiple visual objects of a concept
		let conceptIdOfChildSet = new Set()
		for (let i = 0; i < childArray.length; i++) {

			printTableRow(pLevel + 1, pMaxLevel, conceptIdOfChildSet.has(childArray[i].concept.id), childArray[i]);

			conceptIdOfChildSet.add(childArray[i].concept.id);
		}
		return
	}
}

/**
 * Sorting function
 * 	sort visual object from top to bottom and left to right like reading
 * 
 * @param a visual object
 * @param b visual object
 */
function sortPosition(a, b) {
	// jArchi 0.0 point is the top left corner
	// - x coordinates are 'normal'
	// - y coordinates are opposite to 'normal'
	// check if boxes are on the same 'line' 
	if ((a.bounds.y + a.bounds.heigth < b.bounds.y) &&
		(a.bounds.y > b.bounds.y + b.bounds.heigth))
		return b.bounds.x - a.bounds.x
	else
		return (a.bounds.y - b.bounds.y)
}

/**
 * tableCell2HTML()
 *	markdown wants "Cell content must be on one line only"
 * 	this function converts a multiline markdown string to a single line HTML string
 * 
 * @param src multi line markdownstring
 * 
 */
function tableCell2HTML(src) {

	let htmlString = '';
	src = src.trim();

	if (src) {

		src = markdown2HTML(src);

		// remove excess of new lines and line breaks
		htmlString = src.replace(/(?:\r\n|\r|\n)/g, '<br>');
	}

	return htmlString;

	/**
	 * markdown2HTML
	 * 	convert a markdown string to a HTML string
	 * 
	 * based on https://github.com/adamvleggett/drawdown
	 * 	(c) Adam Leggett
	 * 
	 * removed newlines in the created HTML string for use in a markdown table
	 */
	function markdown2HTML(src) {

		function replace(rex, fn) {
			src = src.replace(rex, fn);
		}

		function element(tag, content) {
			return "<" + tag + ">" + content + "</" + tag + ">";
		}

		function blockquote(src) {
			return src.replace(/\n *&gt; *([^]*?)(?=(\n|$){2})/g,
				function (all, content) {
					return element("blockquote", blockquote(content.replace(/^ *&gt; */gm, "")));
				});
		}

		function list(src) {
			return src.replace(/\n( *)([*\-+]|((\d+)|([a-z])|[A-Z])[.)]) +([^]*?)(?=(\n|$){2})/g,
				function (all, ind, _, ol, num, low, content) {
					var rind = "\n {0," + (ind.length + 1) + "}";
					var entry = content.split(
						RegExp(rind + "(?:(?:\\d+|[a-zA-Z])[.)]|[*\\-+]) +", "g")).map(list);

					return (ol ?
							"<ol start='" + (num ?
								ol + "'>" :
								(parseInt(ol, 36) - 9) + "' style='list-style-type:" + (low ? "low" : "upp") + "er-alpha'>") :
							"<ul>")
						// + element("li", highlight(entry.join("</li>\n<li>").replace(RegExp(rind,"g"),"\n")))
						+
						element("li", highlight(entry.join("</li><li>").replace(RegExp(rind, "g"), "\n"))) +
						(ol ? "</ol>" : "</ul>");
				});
		}

		function highlight(src) {
			return src.replace(/(^|\W|_)(([*_])|(~)|`)(\2?)([^<]*?)\2\5(?!\2)(?=\W|_|$)/g,
				function (all, _, p1, bi, ss, p2, content) {
					return _ + element(
						bi ? (p2 ? "b" : "i") :
						ss ? (p2 ? "s" : "sub") : "code",
						highlight(content));
				});
		}

		var stash = [];
		var si = 0;

		// src = "\n" + src + "\n";

		replace(/</g, "&lt;");
		replace(/>/g, "&gt;");
		replace(/\t|\r/g, "  ");

		// blockquote
		src = blockquote(src);

		// horizontal rule
		replace(/^([*\-=_] *){3,}$/gm, "<hr/>");

		// list
		src = list(src);

		// code
		replace(/\n((```|~~~).*\n?([^]*?)\2|((    .*?\n)+))/g, function (all, p1, p2, p3, p4) {
			stash[--si] = element("pre", element("code", p3 || p4.replace(/^    /gm, "")));
			return si + "\r";
		});

		// link or escape
		replace(/((!?)\[(.*?)\]\((.*?)( ".*")?\)|\\([\\`*_{}\[\]()#+\-.!~]))/g, function (all, p1, p2, p3, p4, p5, p6) {
			stash[--si] = p4 ?
				(p2 ?
					"<img src='" + p4 + "' alt='" + p3 + "'/>" :
					p3.link(p4)) :
				p6;
			return si + "\r";
		});

		// heading
		replace(/(?=^|>|\n)([>\s]*?)(#{1,6}) (.*?)( #*)? *(?=\n|$)/g, function (all, _, p1, p2) {
			return _ + element("h" + p1.length, highlight(p2));
		});

		// paragraph
		replace(/(?=^|>|\n)\n+([^<]+?)\n+(?=\n|<|$)/g, function (all, c) {
			return element("p", highlight(c));
		});

		// stash
		replace(/-\d+\r/g, function (all) {
			return stash[+all];
		});

		return src;
	};
}
/*
 * Import elements from CSV
 * 
 * Requires jArchi - https://www.archimatetool.com/blog/2018/07/02/jarchi/
 * Requires PapaParse - https://www.papaparse.com/
 * Works with Export to CSV Script - https://gist.github.com/smileham/15c445b17a92bd6f5dc1508e573bcd8a
 * 
 * Version 1: Import from CSV
 *
 * (c) 2018 Steven Mileham
 * 
 * Mark Backer
 * Version 2: Added finding existing elements with a custom "id" in a property.
 * 
 * - the CustomIDproperty is used for exchanging elements en relation between multiple architecture tools. 
 * 	Inputformat of the relation CSV:
 *	- use the script "Export to CSV.ajs" to create a spreadsheet with all the columns
 * 	- first columns are defined in elementHeaderDef
 * 		- column 1 to 4 the jArchi relation attributes
 *	 	- extra columns in the CSV are saved as properties. The header label is used as the property name
 * 	The import script adds to each imported object a property customImportLog as a logline for future reference in the architecture model
 */

load(__DIR__ + "common/Export-import to CSV.ajs");

var error = new Error();
var debug = false;
var info = true;

var ImportDate  = new Date().toLocaleDateString();
var ImportLogText = "";
// Custom property for logging import action with element or relation. Set to null for no property
// var customImportLog = "ImportLog";
var customImportLog = null;

var NrElementProcessed = 0;
var NrElementUpdated = 0;
var NrElementCreated = 0;

console.show();
console.clear();

CSVtable = read_CSVdata("element")
if (!CSVtable) {
	console.log("> Canceled, no CSV data ");
} else {
	console.log("> Import CSV");

	CSVheader = CSVtable.data[0];
	debug?console.log("> CSVheader: " + CSVheader):true;
	
	try {
		// skip header, read all rows
		for (var i_row=1; i_row<CSVtable.data.length; i_row++) {
			var cell = [];

			if (CSVtable.data[i_row].length>1) { // skip empty line
				var ElementCreated=false;
				var ElementUpdated=false;

				debug?console.log(`>> CSVtable.data[${i_row}] >  ${CSVtable.data[i_row]}`):true;
				debug?console.log(">> ======== " ):true;

				// label cell of i_row with headerlabel
				for (var j_col=0; j_col<CSVheader.length; j_col++) {
					cell[CSVheader[j_col]] = CSVtable.data[i_row][j_col].trim();
					debug? console.log(`>>> CSVtable.data[${i_row}] > ${CSVheader[j_col]} = ${cell[CSVheader[j_col]]}`) : true;
				}

				result = FindElement(CustomIDproperty, cell[CustomIDproperty], 
					cell[elementHeaderDef["id"]],
					cell[elementHeaderDef["name"]], cell[elementHeaderDef["type"]]);

				if (result.vElement) {
					element = result.vElement;
					ImportLogText = `(Found ${result.vFindImportText})`;
					//	element.prop(customImportLog, ">> Updated at " + ImportDate + " via \"" + result.vFindImportText + "\"");
				} else {
					debug? console.log(`>> Create element : ${cell[elementHeaderDef["type"]]} ${cell[elementHeaderDef["name"]]}`) : true;
					element = model.createElement(
						cell[elementHeaderDef["type"]], 
						cell[elementHeaderDef["name"]]);
						ImportLogText = `(Created at ${ImportDate})`;
					// element.prop(customImportLog, " > Created at " + ImportDate);
					ElementCreated=true;
				}

				// import attributes defined in header
				var attribute_i=0;
				for (var label in elementHeaderDef) {
					if (label!="id"){ // id can't be set 
						if (element[label] != cell[elementHeaderDef[label]]){
							var UpdateText = `Set attribute [${label}]: \n${element[label]}\n${cell[elementHeaderDef[label]]}`;

							element[label] = cell[elementHeaderDef[label]];

							ImportLogText += `\n${UpdateText}`;
//							info?console.log(`>>> ${UpdateText}`):true;
							ElementUpdated=true;
						}
					}
					attribute_i++;
				}
				// import all properties	
				for (var j_col=attribute_i; j_col<CSVheader.length; j_col++) {
					// skip empty cells and customImportLog property
					if (cell[CSVheader[j_col]] && (CSVheader[j_col] != customImportLog)) { 
						if (element.prop(CSVheader[j_col]) != cell[CSVheader[j_col]]) {
							var UpdateText = `Set property [${CSVheader[j_col]}]: \n${element.prop(CSVheader[j_col])}\n${cell[CSVheader[j_col]]}`;

							element.prop(CSVheader[j_col], cell[CSVheader[j_col]]);

							ImportLogText += `\n${UpdateText}`;
//							info?console.log(`>>> ${UpdateText}`):true;
							ElementUpdated=true;
						}
					}
				}
				if (customImportLog) {
					ElementCreated || ElementUpdated ? element.prop(customImportLog, `${ImportDate}: ${ImportLogText}`):true;
				}

				ElementCreated || ElementUpdated ? console.log(`===============================\n>> ${element} ${ImportLogText}`):true;

				NrElementProcessed++;
				ElementCreated ? NrElementCreated++:true;
				ElementUpdated && !ElementCreated ? NrElementUpdated++:true;
				} // next line
		}
		console.log("\n>> ======== " );
		console.log(">> Import finished");
		console.log(">>> elements processed : " + NrElementProcessed);
		console.log(">>> elements updated   : " + NrElementUpdated);
		console.log(">>> elements created   : " + NrElementCreated);
		console.log("");
	}
	catch (error) {
		console.log("> Error: " + error);
		console.log("> Error: " + error.stack);
	}
}
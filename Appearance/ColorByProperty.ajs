/*
 * ColorByProperty
 *
 * Color elements by the value of a selected property
 *
 * (c) 2019 Mark Backer
 *
 *
 * load chroma.min.js
 *		chroma.js for all kinds of color conversions and color scales https://gka.github.io/chroma.js/
 *		ColorBrewer colors, see http://colorbrewer2.org/#type=sequential&scheme=Greens&n=3
 */
 load("https://unpkg.com/chroma-js");
 load(__DIR__ + "../_lib/Common.js");
 load(__DIR__ + "../_lib/SelectCollection.js");
 
 initConsoleLog(__FILE__, true);
 
 try {
	let collection = selectVisualObjectsOfType($(selection));
	applyToCollection(collection.filter("element"), ColorByProperty);
} catch (error) {
	console.log(`> ${typeof error.stack == "undefined" ? error : error.stack}`);
}

finishConsoleLog();

/**
 * ColorByProperty
 * 	Generic function to color an element based on a property value
 *
 *  The first time this function is called, the function
 * 	- shows a popup with the properties of the argument pObject
 *  	- select a property by typing a property name (edit the property list)
 *  - draws a legenda with the property values and given colors
 */
function ColorByProperty(obj) {
	// initialize with selection of property en property values
	if (this.FlagFirstTime === undefined) {
		this.FlagFirstTime = true;
		this.viewIndex = new Object();

		// select a property of the selected element
		propertiesList = obj.prop();

		promptText = `Select a property\n`;
		promptText += `   Prefilled with properties from [${obj}]\n`;
		promptText += `   Edit and keep the name of the property`;
		// this.selectedProperty = window.prompt(promptText, `${propertiesList}`);
		this.selectedProperty = "GEMMA type";
		if (this.selectedProperty) {
			if (obj.prop(this.selectedProperty)) {
				this.propertyValues = getPropertyValues(obj, this.selectedProperty);
			} else {
				throw `Invalid selection, property "${this.selectedProperty}" does not exist for ${obj}`;
			}
		} else {
			throw "Cancelled, no property selected";
		}
	}

	if (!this.viewIndex[obj.view]) {
		drawLegenda(obj, this.selectedProperty, this.propertyValues);
		this.viewIndex[obj.view] = true;
		console.log(`>> Coloring view ${obj.view}`);
	}
	console.log(`>>> obj: ${obj}`);

	let color = colorForIndexPosition(obj.prop(this.selectedProperty), this.propertyValues);

	if (color) {
		obj.fillColor = color;
	}
	return;
}

/*
 * getPropertyValues
 *
 * return an array of unique property values in the model for an object type
 */
function getPropertyValues(obj, prop) {
	let propList = [];
	let propIndex = {};

	console.log(`> In the model found values for "${prop}" in concepts of type ${obj.type}:`);

	$(model)
		.find(obj.type)
		.forEach(function (o) {
			let propValue = o.prop(prop);
			if (propValue == undefined || propValue == null || propValue == "") propValue = "";
			if (!propIndex[propValue]) {
				propList.push(propValue);
				propIndex[propValue] = true;
				console.log(`> - ${propValue}`);
			}
		});
	console.log(`> ${propList.length} unique property values`);

	return propList.sort(function (a, b) {
		return a.localeCompare(b);
	});
}

/*
 * colorForIndexPosition
 *
 * Given a value and a list of possible values
 * -> return a color code based on the value's index position
 */

function colorForIndexPosition(pValue, pValueList) {
	// colorscale = chroma.scale('Oranges');
	// colorscale = chroma.scale('Greens');
	// colorscale = chroma.scale('OrRd').classes(3);
	// colorscale = chroma.scale(['yellow', '008ae5']).classes(3).padding([0.1, 0.1]);
	// colorscale 	= chroma.scale('Blues');
	if (pValueList.length > 5) {
		colorscale = chroma.scale("RdYlBu");
	} else {
		colorscale = chroma.scale("Blues").padding([0, 0.2]);
	}
	return `${colorscale(pValueList.indexOf(pValue) / pValueList.length)}`;
}

/*
 * drawLegenda
 *
 * Draw a legenda with the colors of the property values
 */
function drawLegenda(obj, prop, propList) {
	let legendaName = `${obj.type} and property ${prop}`; // "Legenda";

	const HeaderHeight = 30;
	const ItemWidth = legendaName.length * 6; // 180;
	const ItemHeigth = 25;
	const ItemSpacingX = 10;
	const ItemSpacingY = 5;

	// find coordinates of upper right corner for placing legenda
	let maxX = 0;
	let minY = 10000;
	$(`#${obj.view.id}`)
		.find()
		.not("relation")
		.forEach(function (o) {
			maxX = Math.max(o.bounds.x + o.bounds.width, maxX);
			minY = Math.min(o.bounds.y, minY);
		});

	let legenda = obj.view.createObject(
		"group",
		maxX + ItemSpacingX,
		minY,
		ItemWidth + 2 * ItemSpacingX,
		HeaderHeight + propList.length * (ItemSpacingY + ItemHeigth) + ItemSpacingY
	);
	legenda.name = legendaName;
	legenda.figureType = 1; // rectangle => doesn't work
	legenda.fillColor = "#FFFFFF";
	for (let j = 0; j < propList.length; j++) {
		let item = legenda.createObject(
			"note",
			ItemSpacingX,
			HeaderHeight + j * (ItemHeigth + ItemSpacingY),
			ItemWidth,
			ItemHeigth
		);
		item.fillColor = colorForIndexPosition(propList[j], propList);
		item.text = propList[j];
		item.figureType = 1; // rectangle => doesn't work
	}
}

/*
 * IncludeAppearance
 * 
 * Version 1: Shared appearance functions
 * 
 * (c) 2019 Mark Backer
 *
 * load chroma.min.js
 *		chroma.js for all kinds of color conversions and color scales https://gka.github.io/chroma.js/
 *		ColorBrewer colors, see http://colorbrewer2.org/#type=sequential&scheme=Greens&n=3
 */
load(__DIR__ + "../lib/chroma.min.js");

var _filepath = __FILE__.split("/");
var _scriptName = _filepath[_filepath.length-1];
console.log(`> Include script "${_scriptName}"...`);


/*
 * applyToSelection
 * 
 * Apply a (formatting)function to the selection
 * 
 * Behavior
 * 		select model, apply function to objects on all views
 * 		select folder(s), apply function to objects on views in selected (sub)folders
 * 		select view(s), apply function to objects on selected view
 *   	select object(s) in model tree, apply function to all references on all views
 * 
 * If you select on the view
 * 		select one object on view, apply function to selected objects
 * 			if parameter applyToType, apply function to all elements of same type; 
 * 		select multiple objects in view, apply function to selected objects
 * 			if parameter applyToType, apply function to selected elements of same type as first selected object; 
 * 
 * Parameters:
 * 	pSelection - the selection
 * 	pFunc - formatting of set_properties function
 *  pApplyToFilter - if true (and a concept is selected), apply function to objects of the concepttype of the selection
 *  pFuncParam - optional parameters for function
 * 		
 */
function applyToSelection(pSelection, pFunc, pFuncParam) {
	var SelectionType;
	var archiCollectionType = [
		'archimate-model',
		'folder',
		'archimate-diagram-model', //  'view' also selects sketch and canvas
		'concept',
		'diagram-model-note',
		'diagram-model-group',
		'diagram-model-connection',
		'diagram-model-image',
		'diagram-model-reference'
	];

	try {
		for (var j=0; j<archiCollectionType.length; j++) {
			if (pSelection.is(archiCollectionType[j])) {
				SelectionType = archiCollectionType[j]
			}
		}
		console.log(`> You've selected a ${SelectionType}`)

		switch (SelectionType) {
			case 'archimate-model': {
				console.log(`>> ${pFunc.name}() will be applied to objects on all views in [${model}]\n`);
				applyToAllViews(pSelection, pFunc, pFuncParam)
				break;
			}
			case 'folder': {
				console.log(`>> ${pFunc.name}() will be applied to objects on all views in selected folders\n`);
				applyToViewsInFolder(pSelection, pFunc, pFuncParam)
				break;
			}
			case 'archimate-diagram-model': {
				console.log(`>> ${pFunc.name}() will be applied to objects on selected views\n`);
				applyToViews(pSelection, pFunc, pFuncParam)
				break;
			}
			case 'concept': {
				var NumberSelected;
				var SelectedIn;
				var	selectedElement = pSelection.filter("concept").first();
				if (selectedElement.id == selectedElement.concept.id){
					SelectedIn = "model tree"
				} else {
					SelectedIn = "view"
				}

				if (pSelection.filter("concept").size() == 1){
					NumberSelected = "One concept is"
				} else {
					NumberSelected = "Multiple concepts are"
				}

				ConceptSelectionType = `${NumberSelected} selected in ${SelectedIn}`
				console.log(`>> ${ConceptSelectionType}`)
				switch (ConceptSelectionType) {
					case "One concept is selected in model tree": {
						console.log(`>> ${pFunc.name} will be applied to objects of ${selectedElement.type} on all views in [${model}]\n`);

						applyToElementTypeAllView(pSelection, pFunc, pFuncParam)
						break
					}
					case "One concept is selected in view": {
						console.log(`>> ${pFunc.name} will be applied to all ${selectedElement.type} in view "${selectedElement.view.name}"\n`);
						
						applyToElementTypeOnView(pSelection, pFunc, pFuncParam)
						break
					}
					case "Multiple concepts are selected in view": {
						console.log(`>> ${pFunc.name} will be applied to selected objects in view "${selectedElement.view.name}"\n`);
							
						applyToSelectionOnView(pSelection, pFunc, pFuncParam)
						break
					}
					case "Multiple concepts are selected in model tree": {
						console.log(`>> Not possible, select one object in the tree or make selection in a view\n`);
						break
					}
					default:
				}
				break;
			}
			case 'diagram-model-note':
			case 'diagram-model-group':
			case 'diagram-model-connection':
			case 'diagram-model-image':
			case 'diagram-model-reference': {
				console.log(`> That's a visual element`)
				break;
			}
			default:
		}
	}
	catch (error) {
		console.log(`>> ${arguments.callee.name}(): ${typeof error.stack == 'undefined' ? error : error.stack}`);
	}
}

function ColorByProperty(pObject, pColorFunc) {
	// initialize with selection of property en property values
	if ( typeof this.FlagFirstTime == 'undefined' ) {
		// JS functions are also objects -- which means they can have (static) properties
		this.FlagFirstTime = true;
		this.viewSet = new Set();
		this.colorFunc = pColorFunc;

		if (!pColorFunc) {
			this.colorFunc = colorForIndexPosition;
		}
		console.log(`>>> Color function is : ${pColorFunc.name}`);

		/*
			Prefer to start with selectedElement. To be sure that the colorfunc initializes with a known element
			reason: the ColorByProperty shows the list of properties from the first element
			property = pColorFunc(selectedElement);
			if (!property) {
				throw ('No valid property')
			}
			// i++; // count selectedElement
			Can't get a collection minus selectedElement
			not(selectedElement) not working?? 
			$(selectedElement.view).not(selectedElement).find(selectedElement.type).forEach(function(occurrence) {

			Sollution in ColorByProperty(); show in popup which element is used for property list
		*/

		// select a property of the selected element
		propertiesList = pObject.prop();

		promptText = `Select a property\n`
		promptText += `   Prefilled with properties from [${pObject}]\n`
		promptText += `   Edit and keep the name of the property`
		this.selectedProperty = window.prompt(promptText, `${propertiesList}`)
		if (this.selectedProperty) {
			if (pObject.prop(this.selectedProperty)){

				console.log(`>>> Color by property : ${this.selectedProperty}`);
				// this(pObject.view, pObject.type, selectedProperty)
				this.propertyValues = getPropertyValues(pObject.view, pObject.type, this.selectedProperty);
			} else {
				throw (`Invalid selection, property "${this.selectedProperty}" does not exist for ${pObject}`);
			}
		} else {
			throw ('Cancelled, no property selected');
		}
	}

	if (!viewSet.has(pObject.view)) {
		drawLegenda(pObject.view, this.selectedProperty, this.propertyValues)
		viewSet.add(pObject.view);
	}

	var color = this.colorFunc(pObject.prop(this.selectedProperty), this.propertyValues);

	if (color) {
		pObject.fillColor=color;
	}
	return this.selectedProperty
}

/*
 * getPropertyValues
 * 
 * return an array of property values, filter the duplicates
 * 
 * given a view, the the property values of the objects on the view are returned
 * without a view, all the objects in the model are evaluated
 * 
 */
function getPropertyValues(pView, pObjectType, pProperty)
{
	let myPropertySet = new Set()
	var myList = [];
	var evaluateSelection;

	if (pView) {
		evaluateSelection = pView
	} else {
		evaluateSelection = model
	}

	$(evaluateSelection).find(pObjectType).forEach(function(occurrence) {
		myPropertySet.add(occurrence.prop(pProperty));
	})
	console.log(`>> Evaluated objects for property values: all objects in "${evaluateSelection}" of type ${pObjectType}`)
	console.log(`>> Found ${myPropertySet.size} unique values for "${pProperty}"`)

	for (let item of myPropertySet) {
		myList.push(item); // convert set to array
		console.log(`>>> ${item}`);
	}
	return myList;
}

/*
 * colorForIndexPosition
 * 
 * Given a value and a list of possible values 
 * -> return a color code based on the value's index position
 */
function colorForIndexPosition(pValue, pValueList)
{
	// console.log(`>> pValue, list: ${pValue}, ${pValueList}`)
	// console.log(`>> pValueList.index: ${pValueList.indexOf(pValue)}`)
	// console.log(`>> pValueList.length: ${pValueList.length}`)
	if (pValueList.length > 5) {
		colorscale = chroma.scale('RdYlBu');
	} else {
		colorscale = chroma.scale('Blues').padding([0, 0.2]);
	}
	return colorscale((pValueList.indexOf(pValue))/pValueList.length);
}

/*
 * drawLegenda
 * 
 * Draw a legenda with the colors of the property values
 */
function drawLegenda(pView, pProperty, pPropertyValues)
{
	// Add a visual group Legenda to view
	maxX = 0;
	minY = 0;

	// create a 'collection' of pView for finding all view elements
	$(`#${pView.id}`).find("element").forEach(function(occurrence){
		maxX = Math.max(occurrence.bounds.x + occurrence.bounds.width, maxX);
		minY = Math.min(occurrence.bounds.y, minY);
	});
	// Determine position of the legenda
	ItemWidth = 140;
	ItemHeigth = 25;
	HeaderHeight = 30;
	ItemSpacingX =10;
	ItemSpacingY = 5;

	var group = pView.createObject("group", 
		maxX + ItemSpacingX,
		minY,
		ItemWidth + (2 * ItemSpacingX),
		HeaderHeight + ItemSpacingY + (ItemHeigth * pPropertyValues.length) + (ItemSpacingY * pPropertyValues.length)
	);
	group.name = pProperty // "Legenda";
	group.figureType = 1;
	group.fillColor = "#FFFFFF"
	for (var j=0; j<pPropertyValues.length; j++) {
		note = group.createObject("note",
			ItemSpacingX, 
			HeaderHeight + (j* (ItemHeigth+ItemSpacingY) ), 
			ItemWidth, 
			ItemHeigth)
		note.fillColor = colorForIndexPosition(pPropertyValues[j], pPropertyValues)
		note.text = pPropertyValues[j];
		note.figureType = 1; // rectangle
	}
}

function applyToAllViews(pSelection, pFunc, pFuncParam) {
	var i=0;
	var v=0;
	$('view').each(function(view) {
		console.log(`>> View: "${view.name}"`);
		$(view).find('concept').each(function(occurrence){
			pFunc(occurrence, pFuncParam);
			i++;
		})
		v++;
	})
	console.log(`${pFunc.name} applied to ${i} elements in ${v} views`)
}

function applyToViewsInFolder(pSelection, pFunc, pFuncParam) {
	var i=0;
	var v=0;
	//pSelection.add(pSelection.find('folder'))
	pSelection.filter('folder').each(function(folder){
		console.log(`> Folder ${folder.name}`);
		$(folder).find('view').each(function(view){
			console.log(`>> View: "${view.name}"`);
			$(view).find('concept').each(function(occurrence){
				pFunc(occurrence, pFuncParam);
				i++;
			})
			v++;
		})
	})
	console.log(`${pFunc.name} applied to ${i} elements in ${v} views`)
}

function applyToViews(pSelection, pFunc, pFuncParam) {
	var i=0;
	var v=0;
	$(pSelection).filter('view').each(function(view){
		console.log(`>> View: "${view.name}"`);
		$(view).find('concept').each(function(occurrence){
			pFunc(occurrence, pFuncParam);
			i++;
		})
		v++;
	})	
	console.log(`${pFunc.name} applied to ${i} elements in ${v} views`)
}

function applyToElementTypeAllView(pSelection, pFunc, pFuncParam) {
	var i=0;
	var v=0;
	// Reset formatting in all referenced views
	let ViewSet = new Set()
	$(pSelection).objectRefs().each(function(occurrence){
//		pFunc(occurrence, pFuncParam);
		ViewSet.add(occurrence.view.name);
		i++;
	})
	v = ViewSet.size;
	// console.log(`>> Concepts found on ${v} views`)
	// for (let view of ViewSet) { 
	// 	console.log(`>>> ${view}`); 
	// }		
	console.log(`Function not applied to ${i} elements in ${v} views`)
}

function applyToElementTypeOnView(pSelection, pFunc, pFuncParam) {
	var i=0;
	var v=0;
	selectedElement = pSelection.first();
	$(selectedElement.view).find(selectedElement.type).forEach(function(occurrence) {
		if (!pFunc(occurrence, pFuncParam)) {
			throw (`in ${pFunc.name}`);
		}
		i++;
	})
	console.log(`${pFunc.name} applied to ${i} elements of type ${selectedElement.type} in view "${selectedElement.view.name}"`)
}

function applyToSelectionOnView(pSelection, pFunc, pFuncParam) {
	var i=0;
	var v=0;
	selectedElement = pSelection.first();

	$(pSelection).each(function(occurrence){
		pFunc(occurrence, pFuncParam);
		i++;
	})
	v++;
	console.log(`${pFunc.name} applied to ${i} elements of type ${selectedElement.type} in view "${selectedElement.view.name}"`)
}
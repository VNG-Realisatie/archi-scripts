/**
/**
 * export_compact.ajs
 * 
 * Export Object_ID, id and other object properties of selection
 * The applyToModelContent function allows for multiple kinds of selections
 * 
 */
load(__DIR__ + "../_lib/papaparse.min.js");

load(__DIR__ + "../_lib/Common.js");
load(__DIR__ + "../_lib/SelectCollection.js");

_commonShowDebugMessage = [false];

const OBJECT_ATTRIBUTES = ["id", "type", "name", "documentation"];
const ENDPOINTS = ["source", "target"];

var header = [];
var data = [];
var uniq = [];

initConsoleLog(__FILE__)

try {
	
	let collection = selectConcepts($(selection));
	
	console.log('Exporting selected elements\n')
	applyToCollection(collection.filter("element"), exportElement);
	
	console.log('\nExporting selected relations\n')
	applyToCollection(collection.filter("relation"), exportElement);

	let datum = new Date();
	let exportFile = window.promptSaveFile({
		title: "Export to CSV",
		filterExtensions: ["*.csv"],
		fileName: `${datum.toLocaleDateString('nl-NL')} ${model.name}-${$(selection).first().name}.csv`
	});

	uniq = removeDuplicates(data, "id");

	console.log(`>> uniq.length: ${uniq.length}`)

	if (exportFile != null) {
		$.fs.writeFile(exportFile, Papa.unparse({ fields: header, data: uniq }));
		console.log("\nExported to : " + exportFile);
	} else {
		console.log("\nExport CSV canceled");
	}
} catch (error) {
	console.log(`> ${error}`);
}

finishConsoleLog()

/**
 * Remove duplicates from an array of objects
 * 
 * @param array 
 * @param prop 
 */
function removeDuplicates(array, prop) {
	var noDupArray = [];
	var index  = {};

	for (let i in array) {
		if (index[array[i][prop]] === undefined) {
			noDupArray.push(array[i]);
		}
		index[array[i][prop]] = array[i];
	}
	return noDupArray;
}

  
/**
 * Fill header-row with labels, each label only once
 * @param pLabel 
 */
function headerLabel(pLabel) {
	if (typeof this.FlagFirstTime == 'undefined') {
		// JS functions are also objects -- which means they can have (static) properties
		this.FlagFirstTime = true;
		this.headerIndex = [];
	}

	if (!headerIndex[pLabel]) {
		this.header.push(pLabel);
		headerIndex[pLabel] = true;
	}
}

/**
 * Export an element as a csv row
 * 
 * @param obj 
 */
function exportElement(obj) {
	let row = new Object;

	OBJECT_ATTRIBUTES.forEach(function (attribute) {
		headerLabel(attribute)
		row[attribute] = obj[attribute];
	})

	console.log(`>> ${obj}`)
	obj.prop().forEach(function (propertyLabel) {
		headerLabel(propertyLabel)

		if (obj.prop(propertyLabel)) {
			row[propertyLabel] = obj.prop(propertyLabel);
			debug(`>> Row[${propertyLabel}]: ${row[propertyLabel]}`);
		}
	})

	debug(`>> Row ${row}`)

	this.data.push(row)
}

/**
 * Export a relation as a csv row
 * 
 * @param obj 
 */
function exportRelation(obj) {
	let selectedObject = concept(obj);

	// alle relaties
	// verwijder relaties met source of target die niet geselecteerd zijn (gaat niet vanuit applySelection)
	debug(`====`)
	console.log(`>> ${selectedObject}`)
	console.log(`>>> with relationships: ${$(selectedObject).outRels()}`)

	$(selectedObject).outRels().each(function (r) {
		let row = new Object;

		debug(`>>> export ${r}`)

		// export relation attributes
		OBJECT_ATTRIBUTES.forEach(function (attribute) {
			headerLabel(attribute)

			debug(`>>>> Row[${attribute}] = ${r[attribute]}`)
			row[attribute] = `${r[attribute]}`;
		})

		// export relation properties
		r.prop().forEach(function (propertyLabel) {
			headerLabel(propertyLabel)

			if (r.prop(propertyLabel)) {
				row[propertyLabel] = r.prop(propertyLabel);
				debug(`>>>> Row[${propertyLabel}]: ${row[propertyLabel]}`);
			}
		})

		// export relation endpoint attributes
		ENDPOINT_LABELS.forEach(function (endpoint) {
			OBJECT_ATTRIBUTES.forEach(function (attribute) {
				headerLabel(`${endpoint}.${attribute}`)

				row[`${endpoint}.${attribute}`] = r[endpoint][attribute];
				debug(`>>>> Row[${endpoint}.${attribute}]: ${r[endpoint][attribute]}`);
			})
		})

		debug(`>> Resulting Row ` + JSON.stringify(row))
		this.data.push(row)
	});
}

/**
 * Always return the concept, also if a diagram occurence is given
 */
function concept(o) {
	if (o.concept)
		return o.concept;
	else
		return o;
}
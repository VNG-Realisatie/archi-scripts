console.log()

let nrFoldersStart = $(model).find('folder').size()
console.log(`Number of folders is ${nrFoldersStart}\n`)

delete_empty_folders()

let nrFoldersRemaining = $(model).find('folder').size()

console.log()
console.log(`Deleted ${nrFoldersStart - nrFoldersRemaining} empty folders of total of ${nrFoldersStart} folders`)
console.log(`${nrFoldersRemaining} folders remaining`)

/**
 * 
 */
function delete_empty_folders(pFolderArray = [], pLevel = 0, pFolder) {

	// Skip first element, use '$(model)' instead
	let queryStmnt = `$(model)`
	let folderPath = ''
	for (let i = 0; i < pFolderArray.length; i++) {
		queryStmnt += `.children("folder.${pFolderArray[i]}")`
		folderPath += `/${pFolderArray[i]}`
	}
	// console.log(`Debug: query_stmnt = ${queryStmnt}`)

	let folders_in_folder = eval(`${queryStmnt}.children("folder")`)
	let objects_in_folder = eval(`${queryStmnt}.children()`)

	// stop if folder has no subfolders
	if (folders_in_folder.size() == 0) {
		// if folder is empty, delete folder. The root ande folders with level 1 can't/shouldn't be deleted
		if (pLevel > 1 && objects_in_folder.size() == 0) {
			console.log(`${">".repeat(pLevel)} Delete\t${folderPath}`)
			pFolder.delete()
		} else {
			console.log(`${">".repeat(pLevel)} Keep  \t${folderPath} with ${objects_in_folder.size()} objects`)
		}
		return
	}

	if (folderPath != '') {
		console.log(`${">".repeat(pLevel)} Open  \t${folderPath} with ${folders_in_folder.size()} subfolders`)
	}

	let subLevel = pLevel + 1

	folders_in_folder.each(function (subFolder) {

		pFolderArray.push(subFolder.name)
		delete_empty_folders(pFolderArray, subLevel, subFolder)
		pFolderArray.pop(subFolder.name)

		// reevaluate collection with subfolders
		objects_in_folder = eval(`${queryStmnt}.children()`)
		if ((pLevel > 1) && (objects_in_folder.size() == 0)) {
			console.log(`${"<".repeat(pLevel)} Delete\t${folderPath}`)
			pFolder.delete()
		}
	})
}
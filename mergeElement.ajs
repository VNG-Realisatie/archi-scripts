/*
 * mergeElement
 * 
 * Version 1: Given an element, the script merges all elements with the same name and the same type to the selected element
 * 
 * From the jArchi .merge method (https://github.com/archimatetool/archi-scripting-plugin/wiki/jArchi-Object#merge)
 * 
 *     Existing diagram instances of the other Archimate element will be replaced with this element
 *     All source and target relationships of the other element are set to this element
 *     Documentatation of the other element is appended to this element's documentation
 *     Properites of the other element are appended to this element's properties
 * 
 *     The other element is not deleted
 * 
 * jArchi merge method always appends the documentation and property values of the merged element
 * - This script only appends if the documentation field or de propertie value is different
 * This script does delete the merged element
 * 
 * (c) 2019 Mark Backer
 *
 */

load(__DIR__ + "Common/Common.ajs");
_console_debug = false;

initConsoleLog(__FILE__)

if ($(selection)) {

	if ($(selection).filter("element").size() == 1) {
		// select one element in view			-> this element is the master
		mergeElement($(selection).first())
	} else {
		console.log(`> Multiple elements selected, select only one element`);
	}
} else {
	console.log(`> Select one element`);
}

finishConsoleLog()

/**
 * 
 */
function mergeElement(pObject) {

	try {

		var masterElement = pObject.concept;

		duplicateElementList = $(`.${masterElement.name}`).filter(masterElement.type);
		debug(`duplicateElementList = ${duplicateElementList}`);
		duplicateElementList.not($(`#${masterElement.id}`));
		// duplicateElementList = duplicateElementList.not(masterElement);
		debug(`duplicateElementList = ${duplicateElementList}`)


		if (duplicateElementList.size() == 0) {
			console.log(`> There are no elements with the same name and the same type as "${masterElement.name}"`);
		} else {
			console.log(`> Merge all ${masterElement}`);
			console.log(`> The selected element has the id = ${masterElement.id}\n`)

			duplicateElementList.each(function (duplicateElement) {

				console.log(`> Merge with element: ${duplicateElement.id}`);

				// don't append documentation if documentation strings are equal
				console.log(`>> Merge documentation`);
				if (duplicateElement.documentation == masterElement.documentation) {
					console.log(`>>> equal documentation`);
					duplicateElement.documentation = '';
				} else {
					console.log(`>>> different documentation is appended`);
				}
				var duplicatePropList = duplicateElement.prop();
				debug(`duplicatePropList = ${duplicatePropList}`)
				console.log(`>> Merge properties`);
				for (var i=0; i < duplicatePropList.length; i++) {
					if (masterElement.prop(duplicatePropList[i])) {
						// remove property from duplicate if property is equal to master property
						debug(`masterElement.prop(${duplicatePropList[i]}) = ${duplicateElement.prop(duplicatePropList[i])}`)
						if (masterElement.prop(duplicatePropList[i]) == duplicateElement.prop(duplicatePropList[i])) {
							debug(`>>> equal ${duplicatePropList[i]}`);
							duplicateElement.removeProp(duplicatePropList[i]);
						} else {
							console.log(`>>> appended ${duplicatePropList[i]}`);
						}
					} else {
						console.log(`>>> added ${duplicatePropList[i]}`);
					}
				}

				masterElement.merge(duplicateElement);
				duplicateElement.delete();
			});

			console.log(`\n> ${duplicateElementList.size()} elements merged and deleted`);
		}
	}
	catch (error) {
		console.log(`>> ${arguments.callee.name}(): ${typeof error.stack == 'undefined' ? error : error.stack}`);
	}
}

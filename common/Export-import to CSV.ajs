/*
 * Export-import To CSV
 * 
 * Version 1: Common functions and headers voor Export and Import to CSV
 * 
 * (c) 2019 Mark Backer
 *
 */ 
// Custom id for finding existing elements
var customID = "Object ID";
// Custom property for logging import action with element or relation
var customImportLog = "ImportLog";


var E_I_Debug = false;
var E_I_Info = false;

load(__DIR__ + "../lib/papaparse.min.js");

// Set up some elementHeaders
var elementHeaderDef = {
	// display: function display() {
	// 	for (var i in this) {
	// 		return "Header label for " + i + " = " + this[i];
	// 	}
	// },
	//	jArchi property: 	"Header",
	id: 				"Element ID",
	name: 				"Element label",
	type: 				"Element type",
	documentation: 		"Element documentation"
};
  
var relationHeaderDef = {
//	"jArchi property" 	"Header",
	id:					"Relationship ID",
	name:				"Relationship label",
	type:				"Relationship type",
	documentation:		"Relationship documentation",
	"source.id":		"Source ID",
	"source.name":		"Source label",
	"source.type":		"Source type",
	"source customID":	"Source " + customID, // custom ID for finding the source element
	"target.id":		"Target ID",
	"target.name":		"Target label",
	"target.type":		"Target type",
	"target customID":	"Target " + customID // custom ID for finding the target element
};

/*
 *	Read CSV file in UTF-8 encoding and return file parsed into an array
 */  
function read_CSVdata(CSVfilename_postfix) {

	var filePath = window.promptOpenFile({ title: "Open CSV with " + CSVfilename_postfix , filterExtensions: ["*.CSV"], fileName: "*.csv" });
	var theCSV ="";
	if (filePath) {
		var FileReader = Java.type("java.io.FileReader");
		var InputStreamReader = Java.type("java.io.InputStreamReader");
		var FileInputStream = Java.type("java.io.FileInputStream");
		var theCSVFile = new InputStreamReader(new FileInputStream(filePath), "UTF-8");

		var data = theCSVFile.read();
		console.log("> Please Wait...");
	
		while(data != -1) {
			var theCharacter = String.fromCharCode(data);
			theCSV+=theCharacter;
			data = theCSVFile.read(); 
		}
		theCSVFile.close();

		console.log("> File Loaded");

		return Papa.parse(theCSV);
	} else {
		console.log("> Cancelled");
	}
}

/*
 *	Save all object to CSV and show some statistics 
 */  
function write_CSVdata(pType, pDuplicate, pHeader, pData, pExportFile) {
	var headerArray = [];

	var i=0;
	console.log("==============");
	console.log("> Exported columns for " + pType );
	for (var label in pHeader) {
		headerArray[i]=pHeader[label];
		i++;
		console.log(">> " + i + " : " + pHeader[label]);
	}
  
	if (pDuplicate.length > 0) {
		console.log("> Info: " + pType + " with multiple occurrences on view: ");
		for (var i = 0; i < pDuplicate.length; i++) {
			console.log(">> ", pDuplicate[i]);
		}
	}

	console.log("> Number of exported " + pType + " : " + pData.length );

	if (pExportFile != null) {
	  var ExportFile = pExportFile.substring(0, pExportFile.length - 4) + ("-" + pType + ".csv");
	  $.fs.writeFile( ExportFile, Papa.unparse({ fields: headerArray,  data: pData }) );
	  console.log("> File : " + ExportFile + "\n");
	} else {
	  console.log("> Save CSV cancelled");
	}
  }

/*
 *	Find Object with property en propertyvalue
 */  
function FindObjectWithProperty(pConcept, pProperty, pValue) {
	var vSelectedObject = null;
	E_I_Debug?console.log(">>> FindObjectWithProperty() > (pConcept=" + pConcept + ", pProperty=" + pProperty + ", pValue=" + pValue + ")"):true;
	if (pValue) { // alleen zoeken met geldige waarde
		$(pConcept).each(function(vObject) {
		//	console.log("> vObject : " + vObject);
			if (vObject.prop(pProperty) == pValue) {
				E_I_Debug?console.log(">>> FindObjectWithProperty() > " + pConcept + " found : " + vObject + " with " + pProperty + " = " + pValue):true;
				vSelectedObject = vObject;
			}
		}); // each vObject
	}
	return vSelectedObject;
} 

/*
 *	Try to find an existing element.
 *	Priority for finding an element
 *	- return element found with a given property value
 * 	- else return element found with Archi id
 * 	- else return element found by name.
 *  	- return the first if there are multiple elements with the same name
 */  
function FindElement(pCell, pProperty, pSelectID, pSelectName, pType) {
	var vElement = null;
	var vFindImportText = "";

	// Select the vElement with property
	E_I_Debug? console.log(">> FindElement() > " + pProperty + " = " + pCell[pProperty] ) : true;
	vElement = FindObjectWithProperty("element",  customID, pCell[pProperty]);

//	if (!vElement || vElement.length<1) { // if there is no vElement with the customID
	if (!vElement) { // if there is no vElement with the customID
			// Select the vElement with the id.
		vSelectID ="#" + pCell[pSelectID];
		E_I_Debug? console.log(">> FindElement() > " + pSelectID + " = " + vSelectID): true;
		vElementCollection = $(vSelectID); // Result is collection of elements with #id

		if (!vElementCollection || vElementCollection.size() < 1) { // if there is no vElement with the id
			vSelectName = "." + pCell[pSelectName];
			E_I_Debug? console.log(">> FindElement() > " + pSelectName + " = " + vSelectName ):true;
			if (!pCell[pType]) { // elementtype is known
				throw "Element without type "  + pSelectName + " = " + vSelectName;
			}
			vElementCollection = $(vSelectName).filter(pType);

			if (!vElementCollection || vElementCollection.size()<1) { // if there is no vElement with the name
				vFindImportText = "Not found";
			} else {
				if (vElementCollection.size()>1) {
					vFindImportText = pSelectName + ": Multiple elements found, number = " + vElementCollection.size();
				} else {
					vFindImportText = pSelectName;
				}
			}
		} else {
			vFindImportText = pSelectID;
		}
		vElement = vElementCollection.first();
	} else {
		vFindImportText = pProperty;
	}

	E_I_Info? console.log(">> FindElement() : " + vFindImportText + " > " + vElement):true;
	return {vElement:vElement, vFindImportText:vFindImportText}
}


